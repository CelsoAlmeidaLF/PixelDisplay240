// --- PixelStream Studio IDE v5 ---
// Advanced Embedded UI Design Suite - Clean OOP Implementation

class EditorModule {
    constructor() {
        this.dom = (id) => {
            const el = document.getElementById(id);
            if (!el && !['status-memory', 'status-time'].includes(id)) {
                // Silently return null for missing elements instead of throwing
            }
            return el;
        };
    }
}

// ========== 1. Theme & Palette Manager ==========
class ThemeManager extends EditorModule {
    constructor() {
        super();
        this.presets = {
            gameboy: ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
            pico8: ['#000000', '#1D2B53', '#7E2553', '#008751', '#AB5236', '#5F574F', '#C2C3C7', '#FFF1E8', '#FF004D', '#FFA300', '#FFEC27', '#00E436', '#29ADFF', '#83769C', '#FF77A8', '#FFCCAA'],
            nes: ['#7C7C7C', '#0000FC', '#0000BC', '#4428BC', '#940084', '#A80020', '#A81000', '#881400', '#503000', '#007800', '#006800', '#0058F8', '#004058', '#000000']
        };
        this._init();
    }

    _init() {
        const paletteSel = this.dom('palette-presets');
        if (paletteSel) paletteSel.onchange = () => this.loadPalette(paletteSel.value);

        const btnSave = this.dom('btn-save-color');
        if (btnSave) btnSave.onclick = () => this.addColor(this.dom('color-picker').value);
    }

    loadPalette(id) {
        if (id === 'custom') return;
        const grid = this.dom('color-palette');
        if (!grid) return;
        grid.querySelectorAll('.palette-color').forEach(c => c.remove());
        if (this.presets[id]) this.presets[id].forEach(c => this.addColor(c));
    }

    addColor(color) {
        const grid = this.dom('color-palette');
        if (!grid) return;
        const item = document.createElement('div');
        item.className = 'palette-color';
        item.style.backgroundColor = color;
        item.onclick = () => { if (this.dom('color-picker')) this.dom('color-picker').value = this.rgbToHex(color); };
        item.oncontextmenu = (e) => { e.preventDefault(); item.remove(); };
        const btn = this.dom('btn-save-color');
        if (btn) grid.insertBefore(item, btn); else grid.appendChild(item);
    }

    rgbToHex(rgb) {
        if (rgb.startsWith('#')) return rgb;
        const p = rgb.match(/\d+/g);
        if (!p) return rgb;
        return "#" + p.map(v => parseInt(v).toString(16).padStart(2, '0')).join("");
    }
}

// ========== 2. Navigation Manager ==========
class NavigationManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.panels = {
            design: this.dom('design-view'),
            prototype: this.dom('prototype-view'),
            hardware: this.dom('hardware-view')
        };
        this.btns = {
            design: this.dom('nav-design'),
            prototype: this.dom('nav-prototype'),
            hardware: this.dom('nav-hardware')
        };
        this._setup();
    }

    _setup() {
        Object.keys(this.btns).forEach(id => {
            if (this.btns[id]) this.btns[id].onclick = () => this.switch(id);
        });
    }

    switch(viewId) {
        Object.keys(this.panels).forEach(k => {
            if (this.panels[k]) this.panels[k].classList.toggle('active', k === viewId);
            if (this.btns[k]) this.btns[k].classList.toggle('active', k === viewId);
        });

        if (viewId === 'prototype') {
            this.app.prototype.sync();
        }

        if (this.app.status) this.app.status.update(viewId);
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// ========== 3. Layout Manager (Grid, Rulers, Guides, Zoom) ==========
class LayoutManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.gridCanvas = this.dom('grid-canvas');
        this.gridCtx = this.gridCanvas ? this.gridCanvas.getContext('2d') : null;
        this.rulerH = this.dom('ruler-h');
        this.rulerV = this.dom('ruler-v');
        this.guides = this.dom('guides-container');

        this._setupEvents();
    }

    _setupEvents() {
        const toggleGrid = this.dom('toggle-grid');
        if (toggleGrid) toggleGrid.onchange = () => this.renderGrid();

        const toggleRuler = this.dom('toggle-ruler');
        if (toggleRuler) toggleRuler.onchange = () => this.updateRulers();

        const toggleGuides = this.dom('toggle-guides');
        if (toggleGuides) toggleGuides.onchange = () => {
            if (this.guides) this.guides.style.display = toggleGuides.checked ? 'block' : 'none';
        };

        const zoomInput = this.dom('work-zoom');
        if (zoomInput) zoomInput.oninput = () => {
            const z = zoomInput.value;
            if (this.dom('work-zoom-val')) this.dom('work-zoom-val').textContent = z + '%';
            const container = document.querySelector('.canvas-container');
            if (container) container.style.transform = `scale(${z / 100})`;
        };

        if (this.rulerH) this.rulerH.onclick = (e) => this._addGuide('v', e, this.rulerH);
        if (this.rulerV) this.rulerV.onclick = (e) => this._addGuide('h', e, this.rulerV);

        const btnClear = this.dom('btn-clear-guides');
        if (btnClear) btnClear.onclick = () => { if (this.guides) this.guides.innerHTML = ''; };
    }

    renderGrid() {
        const active = this.app.layers.active;
        if (!this.gridCtx || !active) return;
        this.gridCtx.clearRect(0, 0, this.gridCanvas.width, this.gridCanvas.height);
        if (!this.dom('toggle-grid')?.checked) return;

        this.gridCtx.strokeStyle = 'rgba(255,255,255,0.1)';
        this.gridCtx.lineWidth = 0.5;
        const step = 10;
        for (let i = 0; i <= this.gridCanvas.width; i += step) {
            this.gridCtx.beginPath(); this.gridCtx.moveTo(i, 0); this.gridCtx.lineTo(i, this.gridCanvas.height); this.gridCtx.stroke();
        }
        for (let j = 0; j <= this.gridCanvas.height; j += step) {
            this.gridCtx.beginPath(); this.gridCtx.moveTo(0, j); this.gridCtx.lineTo(this.gridCanvas.width, j); this.gridCtx.stroke();
        }
    }

    updateRulers() {
        const active = this.app.layers.active;
        if (!this.rulerH || !this.rulerV || !active) return;
        this.rulerH.innerHTML = ''; this.rulerV.innerHTML = '';

        if (!this.dom('toggle-ruler')?.checked) {
            this.rulerH.style.visibility = 'hidden'; this.rulerV.style.visibility = 'hidden';
            return;
        }
        this.rulerH.style.visibility = 'visible'; this.rulerV.style.visibility = 'visible';

        const w = active.canvas.width, h = active.canvas.height;
        const step = 20, major = 100;

        for (let i = 0; i <= w; i += step) {
            const m = document.createElement('div'); m.className = 'ruler-mark';
            m.style.left = i + 'px';
            m.style.height = (i % major === 0) ? '100%' : '40%';
            if (i % major === 0) {
                const l = document.createElement('span'); l.className = 'ruler-label';
                l.textContent = i; l.style.left = (i + 2) + 'px';
                this.rulerH.appendChild(l);
            }
            this.rulerH.appendChild(m);
        }

        for (let i = 0; i <= h; i += step) {
            const m = document.createElement('div'); m.className = 'ruler-mark';
            m.style.top = i + 'px';
            m.style.width = (i % major === 0) ? '100%' : '40%';
            if (i % major === 0) {
                const l = document.createElement('span'); l.className = 'ruler-label';
                l.textContent = i; l.style.top = (i + 2) + 'px';
                this.rulerV.appendChild(l);
            }
            this.rulerV.appendChild(m);
        }
    }

    _addGuide(type, e, ruler) {
        const active = this.app.layers.active;
        if (!active) return;
        const rect = ruler.getBoundingClientRect();
        const pos = type === 'v'
            ? (e.clientX - rect.left) * (active.canvas.width / rect.width)
            : (e.clientY - rect.top) * (active.canvas.height / rect.height);

        const g = document.createElement('div');
        g.className = `guide guide-${type}`;
        if (type === 'v') g.style.left = pos + 'px'; else g.style.top = pos + 'px';
        if (this.guides) this.guides.appendChild(g);
    }
}


// ========== 4. Prototype Manager (MVC) ==========
// Logic fully moved to prototype/model.js, view.js, controller.js
// Powered by C# PrototypeService Minimal APIs

// ========== 5. Layer Manager ==========
class Layer {
    constructor(appRef, name, width, height, dataURL = null, backgroundColor = null) {
        this.app = appRef;
        this.name = name;
        this.visible = true;
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.className = 'canvas-layer';
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        if (dataURL) {
            const img = new Image();
            img.onload = () => {
                this.ctx.drawImage(img, 0, 0, width, height);
                this.app.refresh();
            };
            img.src = dataURL;
        } else if (backgroundColor) {
            this.ctx.fillStyle = backgroundColor;
            this.ctx.fillRect(0, 0, width, height);
        }
    }
}

class LayerManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.layers = [];
        this.activeIndex = 0;
        this.container = this.dom('layers-container');
        this.listEl = this.dom('layers-list');
    }

    add(name = "Camada", dataURL = null, silent = false) {
        const w = parseInt(this.dom('canvas-width')?.value) || 240;
        const h = parseInt(this.dom('canvas-height')?.value) || 240;
        const bg = (this.layers.length === 0) ? (this.dom('bg-color-picker')?.value || '#000000') : null;
        const newLayer = new Layer(this.app, name, w, h, dataURL, bg);
        this.layers.push(newLayer);
        this.activeIndex = this.layers.length - 1;
        if (this.container) this.container.insertBefore(newLayer.canvas, this.dom('temp-canvas'));
        this.updateZIndex();
        this.renderUI();
        if (!silent) this.app.saveHistory();
    }

    select(index) {
        if (!this.layers[index]) return;
        this.activeIndex = index;
        this.renderUI();
    }

    get active() { return this.layers[this.activeIndex]; }

    delete(index) {
        if (this.layers.length <= 1) return;
        this.layers[index].canvas.remove();
        this.layers.splice(index, 1);
        this.activeIndex = Math.min(this.activeIndex, this.layers.length - 1);
        this.app.refresh();
        this.app.saveHistory();
    }

    toggleVisibility(index) {
        const layer = this.layers[index];
        layer.visible = !layer.visible;
        layer.canvas.style.display = layer.visible ? 'block' : 'none';
        this.renderUI();
        this.app.refresh();
    }

    async rename(index) {
        const newName = await this.app.dialog.prompt('Renomear Camada', 'Digite o novo nome:', this.layers[index].name);
        if (newName && newName.trim()) {
            this.layers[index].name = newName.trim();
            this.renderUI();
            this.app.saveHistory();
        }
    }

    updateZIndex() { this.layers.forEach((l, i) => l.canvas.style.zIndex = i); }

    renderUI() {
        if (!this.listEl) return;
        this.listEl.innerHTML = '';
        [...this.layers].reverse().forEach((l, revIdx) => {
            const i = this.layers.length - 1 - revIdx;
            const item = document.createElement('div');
            item.className = `layer-item ${i === this.activeIndex ? 'active' : ''}`;
            item.innerHTML = `
                <span style="cursor:pointer; display:flex; align-items:center;" onclick="event.stopPropagation(); app.layers.toggleVisibility(${i})">
                    <i data-lucide="${l.visible ? 'eye' : 'eye-off'}" style="width:14px; height:14px;"></i>
                </span>
                <span style="flex:1; margin-left:8px;" ondblclick="event.stopPropagation(); app.layers.rename(${i})">${l.name}</span>
                <button class="text-btn" onclick="event.stopPropagation(); app.layers.delete(${i})" title="Excluir">
                    <i data-lucide="trash-2" style="width:14px; height:14px;"></i>
                </button>
            `;
            item.onclick = () => this.select(i);
            this.listEl.appendChild(item);
        });
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// ========== 6. Drawing Manager ==========
class DrawingManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.isDrawing = false;
        this.startX = 0; this.startY = 0;
        this.lastX = 0; this.lastY = 0;
        this.symX = false;
        this.symY = false;
        this.tempCanvas = this.dom('temp-canvas');
        this.tempCtx = this.tempCanvas ? this.tempCanvas.getContext('2d') : null;
        this._setupEvents();
    }

    _setupEvents() {
        const wrapper = this.dom('canvas-wrapper');
        if (wrapper) {
            wrapper.addEventListener('mousedown', (e) => this._onMouseDown(e));
            wrapper.addEventListener('mousemove', (e) => this._onMouseMove(e));
            window.addEventListener('mouseup', () => this._onMouseUp());
        }
        const btnX = this.dom('btn-sym-x'), btnY = this.dom('btn-sym-y');
        if (btnX) btnX.onclick = () => { this.symX = !this.symX; btnX.classList.toggle('active', this.symX); };
        if (btnY) btnY.onclick = () => { this.symY = !this.symY; btnY.classList.toggle('active', this.symY); };
    }

    _getMousePos(e) {
        const active = this.app.layers.active;
        if (!active) return [0, 0];
        const r = this.dom('canvas-wrapper').getBoundingClientRect();
        return [(e.clientX - r.left) * (active.canvas.width / r.width), (e.clientY - r.top) * (active.canvas.height / r.height)];
    }

    _onMouseDown(e) {
        const active = this.app.layers.active;
        if (!active || !active.visible) return;
        this.isDrawing = true;
        [this.startX, this.startY] = this._getMousePos(e);
        [this.lastX, this.lastY] = [this.startX, this.startY];

        // Fix: Explicitly start path for brush to ensure single clicks work
        if (this.app.currentTool === 'brush' || this.app.currentTool === 'eraser') {
            active.ctx.beginPath();
            active.ctx.moveTo(this.startX, this.startY);
        }

        if (this.app.currentTool === 'picker') {
            this._pickColor(this.startX, this.startY);
            this.isDrawing = false;
        } else if (this.app.currentTool === 'fill') {
            this._floodFill(active.ctx, Math.floor(this.startX), Math.floor(this.startY));
            this.isDrawing = false;
            this.app.refresh();
            this.app.saveHistory();
        } else if (this.app.currentTool === 'text') {
            this._drawText(this.startX, this.startY);
            this.isDrawing = false;
        }
    }

    _onMouseMove(e) {
        if (!this.isDrawing || !this.app.layers.active) return;
        const [x, y] = this._getMousePos(e);
        const tool = this.app.currentTool;
        const ctx = this.app.layers.active.ctx;
        const color = this.dom('color-picker')?.value || '#fff';
        const size = parseInt(this.dom('brush-size')?.value) || 2;

        if (tool === 'brush' || tool === 'eraser') {
            ctx.save();
            if (tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';

            const pattern = this.dom('brush-pattern')?.value || 'solid';
            if (pattern !== 'solid') {
                const p = this._createPattern(ctx, pattern, color);
                if (p) ctx.strokeStyle = p; else ctx.strokeStyle = color;
            } else {
                ctx.strokeStyle = color;
            }

            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            this._drawSymmetricStroke(ctx, this.lastX, this.lastY, x, y, size, color);
            ctx.restore();
            [this.lastX, this.lastY] = [x, y];
            this.app.refresh();
        } else if (['line', 'rect', 'circle'].includes(tool)) {
            const pattern = this.dom('brush-pattern')?.value || 'solid';
            this._drawPreview(tool, this.startX, this.startY, x, y, color, size);
        }
    }

    _onMouseUp() {
        if (!this.isDrawing) return;
        this.isDrawing = false;
        const tool = this.app.currentTool;
        const active = this.app.layers.active;
        if (!active) return;

        if (['line', 'rect', 'circle'].includes(tool)) {
            const [x, y] = [this.lastX, this.lastY]; // Should be current mouse pos, but let's use a stored pos if needed
            // Finalize drawing on main canvas
            const color = this.dom('color-picker')?.value || '#fff';
            const size = parseInt(this.dom('brush-size')?.value) || 2;
            this._drawShape(active.ctx, tool, this.startX, this.startY, this.lastX, this.lastY, color, size, true);
            if (this.tempCtx) this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        }

        this.app.refresh();
        this.app.saveHistory();
    }

    _drawSymmetricStroke(ctx, x1, y1, x2, y2, size, color) {
        const w = this.app.layers.active.canvas.width;
        const h = this.app.layers.active.canvas.height;
        this._line(ctx, x1, y1, x2, y2);
        if (this.symX) this._line(ctx, w - x1, y1, w - x2, y2);
        if (this.symY) this._line(ctx, x1, h - y1, x2, h - y2);
        if (this.symX && this.symY) this._line(ctx, w - x1, h - y1, w - x2, h - y2);
    }

    _line(ctx, x1, y1, x2, y2) { ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); }

    _createPattern(ctx, type, color) {
        const pCanvas = document.createElement('canvas');
        pCanvas.width = 4; pCanvas.height = 4;
        const pCtx = pCanvas.getContext('2d');
        pCtx.fillStyle = color;
        if (type === 'checker') {
            pCtx.fillRect(0, 0, 2, 2); pCtx.fillRect(2, 2, 2, 2);
        } else if (type === 'dots') {
            pCtx.fillRect(0, 0, 1, 1);
        } else if (type === 'lines') {
            pCtx.fillRect(0, 0, 4, 1);
        }
        return ctx.createPattern(pCanvas, 'repeat');
    }

    _drawPreview(tool, x1, y1, x2, y2, color, size) {
        if (!this.tempCtx) return;
        this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        this._drawShape(this.tempCtx, tool, x1, y1, x2, y2, color, size, false);
        this.lastX = x2; this.lastY = y2;
    }

    _drawShape(ctx, tool, x1, y1, x2, y2, color, size, symmetric) {
        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.lineCap = 'round';

        const draw = (ctx, x1, y1, x2, y2) => {
            ctx.beginPath();
            if (tool === 'line') {
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            } else if (tool === 'rect') {
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            } else if (tool === 'circle') {
                const r = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                ctx.arc(x1, y1, r, 0, Math.PI * 2);
            }
            ctx.stroke();
        };

        draw(ctx, x1, y1, x2, y2);
        if (symmetric && this.app.layers.active) {
            const w = this.app.layers.active.canvas.width, h = this.app.layers.active.canvas.height;
            if (this.symX) draw(ctx, w - x1, y1, w - x2, y2);
            if (this.symY) draw(ctx, x1, h - y1, x2, h - y2);
            if (this.symX && this.symY) draw(ctx, w - x1, h - y1, w - x2, h - y2);
        }
    }

    _pickColor(x, y) {
        const active = this.app.layers.active;
        if (!active) return;
        const data = active.ctx.getImageData(x, y, 1, 1).data;
        const hex = "#" + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + data[2]).toString(16).slice(1);
        if (this.dom('color-picker')) this.dom('color-picker').value = hex;
    }

    _floodFill(ctx, x, y) {
        const color = this.dom('color-picker').value;
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);

        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;
        const targetColor = this._getPixel(data, x, y, ctx.canvas.width);

        if (this._colorMatch(targetColor, [r, g, b, 255])) return;

        const stack = [[x, y]];
        while (stack.length > 0) {
            const [cx, cy] = stack.pop();
            if (cx < 0 || cy < 0 || cx >= ctx.canvas.width || cy >= ctx.canvas.height) continue;

            const current = this._getPixel(data, cx, cy, ctx.canvas.width);
            if (this._colorMatch(current, targetColor)) {
                this._setPixel(data, cx, cy, ctx.canvas.width, [r, g, b, 255]);
                stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }

    _getPixel(data, x, y, w) {
        const i = (y * w + x) * 4;
        return [data[i], data[i + 1], data[i + 2], data[i + 3]];
    }

    _setPixel(data, x, y, w, color) {
        const i = (y * w + x) * 4;
        data[i] = color[0]; data[i + 1] = color[1]; data[i + 2] = color[2]; data[i + 3] = color[3];
    }

    _colorMatch(c1, c2) {
        return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
    }

    async _drawText(x, y) {
        const text = await this.app.dialog.prompt('Ferramenta de Texto', 'O que você deseja escrever?', '');
        if (text && text.trim()) {
            const active = this.app.layers.active;
            const ctx = active.ctx;
            const color = this.dom('color-picker')?.value || '#fff';
            const size = parseInt(this.dom('brush-size')?.value) || 20;

            ctx.fillStyle = color;
            ctx.font = `${size}px Inter, sans-serif`;
            ctx.textBaseline = 'top';
            ctx.fillText(text, x, y);

            this.app.refresh();
            this.app.saveHistory();
        }
    }
}

// ========== 7. Main App Orchestrator ==========
class PixelStreamApp extends EditorModule {
    constructor() {
        super();
        this.layers = new LayerManager(this);
        this.theme = new ThemeManager();
        this.layout = new LayoutManager(this);

        // REBUILT MVC PROTOTYPE
        const pModel = new PrototypeModel();
        const pView = new PrototypeView();
        this.prototype = new PrototypeController(pModel, pView);

        this.nav = new NavigationManager(this);
        this.drawing = new DrawingManager(this);
        this.stage = new StageManager(this);
        this.currentTool = 'brush';
        this.undoStack = []; this.redoStack = []; this.MAX_HISTORY = 30;
        this.collection = [];
    }

    init(fullClear = false) {
        const w = parseInt(this.dom('canvas-width')?.value) || 240;
        const h = parseInt(this.dom('canvas-height')?.value) || 240;
        const oldData = (!fullClear && this.layers.layers) ? this.layers.layers.map(l => ({ name: l.name, data: l.canvas.toDataURL(), visible: l.visible })) : [];
        if (this.layers.layers) this.layers.layers.forEach(l => l.canvas.remove());
        this.layers.layers = [];
        if (oldData.length > 0) {
            oldData.forEach((d, i) => {
                this.layers.add(d.name, d.data, true);
                this.layers.layers[i].visible = d.visible;
                this.layers.layers[i].canvas.style.display = d.visible ? 'block' : 'none';
            });
        } else { this.layers.add("Fundo", null, true); }
        ['grid-canvas', 'preview-canvas', 'temp-canvas'].forEach(id => {
            const c = this.dom(id); if (c) { c.width = w; c.height = h; }
        });
        const wrapper = this.dom('canvas-wrapper');
        if (wrapper) { wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px'; }
        this._setupTools();
        this._wireUI();
        this.refresh();
    }

    _wireUI() {
        const btnAdd = this.dom('btn-add-layer');
        if (btnAdd) btnAdd.onclick = () => this.layers.add();

        const btnUndo = this.dom('btn-undo');
        if (btnUndo) btnUndo.onclick = () => this.undo();

        const btnRedo = this.dom('btn-redo');
        if (btnRedo) btnRedo.onclick = () => this.redo();

        const brushSize = this.dom('brush-size');
        if (brushSize) brushSize.oninput = (e) => {
            if (this.dom('brush-size-val')) this.dom('brush-size-val').textContent = e.target.value;
        };

        const wInput = this.dom('canvas-width');
        const hInput = this.dom('canvas-height');
        if (wInput) wInput.onchange = () => this.init();
        if (hInput) hInput.onchange = () => this.init();

        const fileInput = this.dom('file-input');
        if (fileInput) fileInput.onchange = (e) => this._importImage(e);

        const btnExport = this.dom('btn-export');
        if (btnExport) btnExport.onclick = () => this._export();

        // Filters
        if (this.dom('filter-gray')) this.dom('filter-gray').onclick = () => this._applyFilter('gray');
        if (this.dom('filter-invert')) this.dom('filter-invert').onclick = () => this._applyFilter('invert');
        if (this.dom('filter-bright')) this.dom('filter-bright').onclick = () => this._applyFilter('bright');
        if (this.dom('filter-contrast')) this.dom('filter-contrast').onclick = () => this._applyFilter('contrast');

        // Layer Actions
        if (this.dom('btn-merge-layers')) this.dom('btn-merge-layers').onclick = () => this._mergeLayers();

        // Project Persistence
        if (this.dom('btn-save-project')) this.dom('btn-save-project').onclick = () => this._saveProject();
        if (this.dom('btn-load-project')) this.dom('btn-load-project').onclick = () => this.dom('project-input').click();
        if (this.dom('project-input')) this.dom('project-input').onchange = (e) => this._loadProject(e);

        // UI Components
        if (this.dom('add-ui-slider')) this.dom('add-ui-slider').onclick = () => this._addUIComponent('slider');
        if (this.dom('add-ui-switch')) this.dom('add-ui-switch').onclick = () => this._addUIComponent('switch');
        if (this.dom('add-ui-bar')) this.dom('add-ui-bar').onclick = () => this._addUIComponent('bar');

        // Collection & Animation
        if (this.dom('btn-add-collection')) this.dom('btn-add-collection').onclick = () => this._addToCollection();
        if (this.dom('btn-export-collection')) this.dom('btn-export-collection').onclick = () => this._exportCollection();

        // Fix Navigation
        const navDesign = this.dom('nav-design');
        if (navDesign) navDesign.onclick = () => this.nav.switch('design');

        const navProto = this.dom('nav-prototype');
        if (navProto) navProto.onclick = () => this.nav.switch('prototype');

        const navHw = this.dom('nav-hardware');
        if (navHw) navHw.onclick = () => this.nav.switch('hardware');
    }

    _addToCollection() {
        const canvas = this.dom('preview-canvas');
        if (!canvas) return;

        if (!this.collection) this.collection = [];

        const dataUrl = canvas.toDataURL('image/png');
        this.collection.push({
            id: Date.now(),
            data: dataUrl,
            width: canvas.width,
            height: canvas.height
        });

        this._renderCollection();
        if (this.prototype) this.prototype.importFromCollection(dataUrl);
        this.toast.show('success', 'Adicionado à Coleção', `Sprite ${this.collection.length} adicionado.`);
    }

    _renderCollection() {
        const list = this.dom('sprite-list');
        if (!list) return;

        list.innerHTML = '';
        if (!this.collection || this.collection.length === 0) {
            list.innerHTML = '<div class="hint">Coleção vazia.</div>';
            return;
        }

        this.collection.forEach((sprite, index) => {
            const item = document.createElement('div');
            item.className = 'layer-item';
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '10px';
            item.style.padding = '5px';
            item.style.cursor = 'pointer';
            item.style.borderBottom = '1px solid var(--border)';

            const img = document.createElement('img');
            img.src = sprite.data;
            img.style.width = '32px';
            img.style.height = '32px';
            img.style.objectFit = 'contain';
            img.style.background = '#000';
            img.style.border = '1px solid var(--border)';

            const name = document.createElement('span');
            name.textContent = `Sprite_${index}`;
            name.style.flex = '1';
            name.style.fontSize = '12px';

            const btnDel = document.createElement('button');
            btnDel.className = 'text-btn small-btn';
            btnDel.innerHTML = '<i data-lucide="trash-2" style="width:14px; color:#ef4444;"></i>';
            btnDel.title = 'Excluir da Coleção';
            btnDel.onclick = (e) => {
                e.stopPropagation();
                this.collection.splice(index, 1);
                this._renderCollection();
            };

            const btnProto = document.createElement('button');
            btnProto.className = 'text-btn small-btn';
            btnProto.innerHTML = '<i data-lucide="monitor-play" style="width:14px; color:#38bdf8;"></i>';
            btnProto.title = 'Enviar para Prototipagem';
            btnProto.onclick = (e) => {
                e.stopPropagation();
                if (this.prototype) {
                    this.prototype.importFromCollection(sprite.data);
                    this.nav.switch('prototype');
                }
            };

            item.appendChild(img);
            item.appendChild(name);
            item.appendChild(btnProto);
            item.appendChild(btnDel);

            // Clicar no item carrega ele de volta pro canvas
            item.onclick = () => {
                if (confirm('Carregar este sprite substituirá o canvas atual. Continuar?')) {
                    // Limpa as layers atuais e carrega a imagem
                    this.layers.layers = [];
                    this.layers.add(`Sprite_${index}`, sprite.data, true);
                    this.layers.render();
                }
            };

            list.appendChild(item);
        });

        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    _exportCollection() {
        if (!this.collection || this.collection.length === 0) {
            return this.toast.show('warning', 'Coleção Vazia', 'Adicione sprites à coleção primeiro.');
        }

        const format = this.dom('export-format')?.value || 'rgb565';
        const arrayName = this.dom('array-name')?.value || 'sprites';

        if (format === 'jpeg') {
            // For collection, we just download each item or the first one?
            // Let's download the first one for now or show a message.
            // Better yet, let's just use the current canvas JPEG export and ignore the collection
            // but tell the user. 
            // Most users who want JPG just want a picture of the screen.
            this.toast.show('info', 'Exportação de Imagem', 'A coleção de C Array não é compatível com JPEG. Exportando imagem individual...');
            this._export();
            return;
        }

        let code = `// Gerado pelo PixelStream IDE v5\n`;
        code += `// Coleção de Sprites: ${this.collection.length} imagens\n`;
        code += `// Formato: ${format.toUpperCase()}\n\n`;
        code += `#include <pgmspace.h>\n\n`;

        const promises = this.collection.map((sprite, index) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = sprite.width;
                    tempCanvas.height = sprite.height;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imgData = ctx.getImageData(0, 0, sprite.width, sprite.height).data;
                    resolve({ index, imgData, width: sprite.width, height: sprite.height });
                };
                img.src = sprite.data;
            });
        });

        Promise.all(promises).then(results => {
            results.forEach(res => {
                const { index, imgData, width, height } = res;
                const spriteName = `${arrayName}_${index}`;

                if (format === 'rgb565') {
                    code += `const uint16_t ${spriteName}[${width * height}] PROGMEM = {\n  `;
                    let count = 0;
                    for (let i = 0; i < imgData.length; i += 4) {
                        const r = imgData[i] >> 3;
                        const g = imgData[i + 1] >> 2;
                        const b = imgData[i + 2] >> 3;
                        const rgb565 = (r << 11) | (g << 5) | b;

                        code += `0x${rgb565.toString(16).padStart(4, '0').toUpperCase()}`;
                        if (i < imgData.length - 4) code += ', ';

                        count++;
                        if (count >= 12) { code += '\n  '; count = 0; }
                    }
                    code += '\n};\n\n';
                } else if (format === 'rle565') {
                    let rleData = [];
                    let currentPixel = -1;
                    let runLength = 0;

                    for (let i = 0; i < imgData.length; i += 4) {
                        const r = imgData[i] >> 3;
                        const g = imgData[i + 1] >> 2;
                        const b = imgData[i + 2] >> 3;
                        const rgb565 = (r << 11) | (g << 5) | b;

                        if (currentPixel === -1) { currentPixel = rgb565; runLength = 1; }
                        else if (currentPixel === rgb565 && runLength < 255) { runLength++; }
                        else { rleData.push(runLength); rleData.push(currentPixel); currentPixel = rgb565; runLength = 1; }
                    }
                    if (runLength > 0) { rleData.push(runLength); rleData.push(currentPixel); }

                    code += `const uint16_t ${spriteName}_rle[${rleData.length}] PROGMEM = {\n  `;
                    let count = 0;
                    for (let i = 0; i < rleData.length; i++) {
                        code += `0x${rleData[i].toString(16).padStart(4, '0').toUpperCase()}`;
                        if (i < rleData.length - 1) code += ', ';
                        count++;
                        if (count >= 12) { code += '\n  '; count = 0; }
                    }
                    code += '\n};\n\n';
                } else if (format === 'rgb888') {
                    code += `const uint32_t ${spriteName}[${width * height}] PROGMEM = {\n  `;
                    let count = 0;
                    for (let i = 0; i < imgData.length; i += 4) {
                        const rgb888 = (imgData[i] << 16) | (imgData[i + 1] << 8) | imgData[i + 2];
                        code += `0x${rgb888.toString(16).padStart(6, '0').toUpperCase()}`;
                        if (i < imgData.length - 4) code += ', ';
                        count++;
                        if (count >= 8) { code += '\n  '; count = 0; }
                    }
                    code += '\n};\n\n';
                }
            });

            // Array de ponteiros para facilitar animação
            code += `// Array de ponteiros para facilitar iteração/animação\n`;
            const type = format === 'rgb888' ? 'uint32_t' : 'uint16_t';
            const suffix = format === 'rle565' ? '_rle' : '';
            code += `const ${type}* const ${arrayName}_frames[${results.length}] PROGMEM = {\n  `;
            code += results.map(r => `${arrayName}_${r.index}${suffix}`).join(', ');
            code += `\n};\n`;

            const blob = new Blob([code], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = `${arrayName}_collection.h`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            this.toast.show('success', 'Coleção Exportada', `Arquivo ${arrayName}_collection.h gerado com sucesso.`);
        });
    }

    _addUIComponent(type) {
        const active = this.layers.active;
        if (!active) return;
        const ctx = active.ctx;
        const color = this.dom('color-picker')?.value || '#fff';
        const w = active.canvas.width;
        const h = active.canvas.height;
        const cx = w / 2;
        const cy = h / 2;

        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;

        if (type === 'slider') {
            ctx.strokeRect(cx - 40, cy - 5, 80, 10);
            ctx.fillRect(cx - 10, cy - 10, 20, 20);
        } else if (type === 'switch') {
            ctx.beginPath();
            ctx.roundRect(cx - 25, cy - 12, 50, 25, 12);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx + 12, cy, 8, 0, Math.PI * 2);
            ctx.fill();
        } else if (type === 'bar') {
            ctx.strokeRect(cx - 50, cy - 8, 100, 16);
            ctx.fillRect(cx - 48, cy - 6, 60, 12);
        }

        this.refresh();
        this.saveHistory();
        this.toast.show('success', 'Componente Adicionado', `${type} criado no centro.`);
    }

    _saveProject() {
        const data = {
            version: '5.0',
            width: parseInt(this.dom('canvas-width')?.value) || 240,
            height: parseInt(this.dom('canvas-height')?.value) || 240,
            layers: this.layers.layers.map(l => ({ name: l.name, data: l.canvas.toDataURL(), visible: l.visible }))
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pixelstream_project.json';
        a.click();
        this.logger.error('Project', 'Projeto exportado com sucesso', { width: data.width, height: data.height, layers: data.layers.length });
        this.toast.show('success', 'Projeto Salvo', 'Arquivo JSON exportado com sucesso.');
    }

    _loadProject(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                if (this.dom('canvas-width')) this.dom('canvas-width').value = data.width || 240;
                if (this.dom('canvas-height')) this.dom('canvas-height').value = data.height || 240;
                this.init(true);
                this.layers.layers.forEach(l => l.canvas.remove());
                this.layers.layers = [];
                data.layers.forEach((l, i) => {
                    this.layers.add(l.name, l.data, true);
                    this.layers.layers[i].visible = l.visible;
                    this.layers.layers[i].canvas.style.display = l.visible ? 'block' : 'none';
                });
                this.refresh();
                this.logger.error('Project', 'Projeto carregado com sucesso', { layers: data.layers.length });
                this.toast.show('success', 'Projeto Carregado', 'O estado do editor foi restaurado.');
            } catch (err) {
                this.logger.error('Project', 'Falha ao carregar JSON', { error: err.message });
                this.toast.show('error', 'Erro no Carregamento', 'Arquivo JSON inválido.');
            }
        };
        reader.readAsText(file);
    }

    _applyFilter(type) {
        const active = this.layers.active;
        if (!active) return;
        const ctx = active.ctx;
        const id = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const d = id.data;
        for (let i = 0; i < d.length; i += 4) {
            if (type === 'gray') { const g = d[i] * 0.3 + d[i + 1] * 0.59 + d[i + 2] * 0.11; d[i] = d[i + 1] = d[i + 2] = g; }
            if (type === 'invert') { d[i] = 255 - d[i]; d[i + 1] = 255 - d[i + 1]; d[i + 2] = 255 - d[i + 2]; }
            if (type === 'bright') { d[i] += 20; d[i + 1] += 20; d[i + 2] += 20; }
            if (type === 'contrast') {
                const factor = (259 * (50 + 255)) / (255 * (259 - 50));
                d[i] = factor * (d[i] - 128) + 128;
                d[i + 1] = factor * (d[i + 1] - 128) + 128;
                d[i + 2] = factor * (d[i + 2] - 128) + 128;
            }
        }
        ctx.putImageData(id, 0, 0);
        this.refresh();
        this.saveHistory();
    }

    _mergeLayers() {
        if (this.layers.layers.length < 2) return;
        const bottom = this.layers.layers[0];
        const bCtx = bottom.ctx;
        for (let i = 1; i < this.layers.layers.length; i++) {
            if (this.layers.layers[i].visible) bCtx.drawImage(this.layers.layers[i].canvas, 0, 0);
            this.layers.layers[i].canvas.remove();
        }
        this.layers.layers = [bottom];
        this.layers.activeIndex = 0;
        this.layers.renderUI();
        this.refresh();
        this.saveHistory();
    }

    _importImage(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                // Dithering opcional na importação
                const applyDithering = confirm("Deseja aplicar dithering (redução de cores) à imagem importada para adequá-la à paleta atual?");
                if (applyDithering) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // Pega a paleta atual (se for preset) ou usa uma padrão de 16 cores
                    const paletteSelect = this.dom('palette-presets');
                    let currentPalette = this.app.theme.presets[paletteSelect?.value] || this.app.ai.palettes[16];

                    // Converte hex para rgb se necessário
                    const rgbPalette = currentPalette.map(c => {
                        if (typeof c === 'string' && c.startsWith('#')) {
                            const hex = c.replace('#', '');
                            return [
                                parseInt(hex.substring(0, 2), 16),
                                parseInt(hex.substring(2, 4), 16),
                                parseInt(hex.substring(4, 6), 16)
                            ];
                        }
                        return c;
                    });

                    this._applyFloydSteinbergDithering(ctx, rgbPalette);
                    this.layers.add(file.name, tempCanvas.toDataURL());
                } else {
                    this.layers.add(file.name, event.target.result);
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    _applyFloydSteinbergDithering(ctx, palette) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;

        const findClosestPaletteColor = (r, g, b) => {
            let minDistance = Infinity;
            let closestColor = palette[0];
            for (const color of palette) {
                const distance = Math.pow(r - color[0], 2) + Math.pow(g - color[1], 2) + Math.pow(b - color[2], 2);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            return closestColor;
        };

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;

                const oldR = data[i];
                const oldG = data[i + 1];
                const oldB = data[i + 2];

                const newColor = findClosestPaletteColor(oldR, oldG, oldB);

                data[i] = newColor[0];
                data[i + 1] = newColor[1];
                data[i + 2] = newColor[2];

                const errR = oldR - newColor[0];
                const errG = oldG - newColor[1];
                const errB = oldB - newColor[2];

                const distributeError = (xOffset, yOffset, factor) => {
                    if (x + xOffset >= 0 && x + xOffset < width && y + yOffset < height) {
                        const idx = ((y + yOffset) * width + (x + xOffset)) * 4;
                        data[idx] = Math.min(255, Math.max(0, data[idx] + errR * factor));
                        data[idx + 1] = Math.min(255, Math.max(0, data[idx + 1] + errG * factor));
                        data[idx + 2] = Math.min(255, Math.max(0, data[idx + 2] + errB * factor));
                    }
                };

                distributeError(1, 0, 7 / 16);
                distributeError(-1, 1, 3 / 16);
                distributeError(0, 1, 5 / 16);
                distributeError(1, 1, 1 / 16);
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    _export() {
        const canvas = this.dom('preview-canvas');
        if (!canvas) return;

        const format = this.dom('export-format')?.value || 'jpeg';
        const arrayName = this.dom('array-name')?.value || 'image_01';

        if (format === 'jpeg') {
            const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
            const link = document.createElement('a');
            link.download = `${arrayName}.jpg`;
            link.href = dataUrl;
            link.click();
            this.toast.show('success', 'Exportação Concluída', `Imagem ${arrayName}.jpg gerada com sucesso.`);
            return;
        }

        const width = canvas.width;
        const height = canvas.height;

        const ctx = canvas.getContext('2d');
        const imgData = ctx.getImageData(0, 0, width, height).data;

        let code = `// Gerado pelo PixelStream IDE v5\n`;
        code += `// Hardware Config:\n`;
        code += `#define TFT_MOSI ${this.dom('pin-mosi')?.value || 23}\n`;
        code += `#define TFT_SCLK ${this.dom('pin-sck')?.value || 18}\n`;
        code += `#define TFT_CS   ${this.dom('pin-cs')?.value || 5}\n`;
        code += `#define TFT_DC   ${this.dom('pin-dc')?.value || 2}\n`;
        code += `#define TFT_RST  ${this.dom('pin-rst')?.value || 4}\n`;
        code += `#define TFT_BL   ${this.dom('pin-bl')?.value || 15}\n\n`;
        code += `// Formato: ${format.toUpperCase()}, Dimensões: ${width}x${height}\n`;
        code += `// Para usar com TFT_eSPI: tft.pushImage(x, y, ${width}, ${height}, ${arrayName});\n\n`;
        code += `#include <pgmspace.h>\n\n`;

        if (format === 'rgb565') {
            code += `const uint16_t ${arrayName}[${width * height}] PROGMEM = {\n  `;
            let count = 0;
            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i] >> 3;
                const g = imgData[i + 1] >> 2;
                const b = imgData[i + 2] >> 3;
                const rgb565 = (r << 11) | (g << 5) | b;

                code += `0x${rgb565.toString(16).padStart(4, '0').toUpperCase()}`;
                if (i < imgData.length - 4) {
                    code += ', ';
                }

                count++;
                if (count >= 12) {
                    code += '\n  ';
                    count = 0;
                }
            }
            code += '\n};\n';
        } else if (format === 'rle565') {
            // Compressão RLE (Run-Length Encoding) para RGB565
            let rleData = [];
            let currentPixel = -1;
            let runLength = 0;

            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i] >> 3;
                const g = imgData[i + 1] >> 2;
                const b = imgData[i + 2] >> 3;
                const rgb565 = (r << 11) | (g << 5) | b;

                if (currentPixel === -1) {
                    currentPixel = rgb565;
                    runLength = 1;
                } else if (currentPixel === rgb565 && runLength < 255) {
                    runLength++;
                } else {
                    rleData.push(runLength);
                    rleData.push(currentPixel);
                    currentPixel = rgb565;
                    runLength = 1;
                }
            }
            // Adiciona o último run
            if (runLength > 0) {
                rleData.push(runLength);
                rleData.push(currentPixel);
            }

            code = `// Gerado pelo PixelStream IDE v5\n`;
            code += `// Formato: RGB565 com Compressão RLE, Dimensões: ${width}x${height}\n`;
            code += `// Tamanho original: ${width * height * 2} bytes | Tamanho comprimido: ${rleData.length * 2} bytes\n`;
            code += `// Função de descompressão necessária no ESP32.\n\n`;
            code += `#include <pgmspace.h>\n\n`;
            code += `const uint16_t ${arrayName}_rle[${rleData.length}] PROGMEM = {\n  `;

            let count = 0;
            for (let i = 0; i < rleData.length; i++) {
                code += `0x${rleData[i].toString(16).padStart(4, '0').toUpperCase()}`;
                if (i < rleData.length - 1) {
                    code += ', ';
                }

                count++;
                if (count >= 12) {
                    code += '\n  ';
                    count = 0;
                }
            }
            code += '\n};\n';
        } else if (format === 'rgb888') {
            code += `const uint32_t ${arrayName}[${width * height}] PROGMEM = {\n  `;
            let count = 0;
            for (let i = 0; i < imgData.length; i += 4) {
                const r = imgData[i];
                const g = imgData[i + 1];
                const b = imgData[i + 2];
                const rgb888 = (r << 16) | (g << 8) | b;

                code += `0x${rgb888.toString(16).padStart(6, '0').toUpperCase()}`;
                if (i < imgData.length - 4) {
                    code += ', ';
                }

                count++;
                if (count >= 8) {
                    code += '\n  ';
                    count = 0;
                }
            }
            code += '\n};\n';
        }

        // Baixar o arquivo .h
        const blob = new Blob([code], { type: 'text/plain' });
        const link = document.createElement('a');
        link.download = `${arrayName}.h`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);

        this.toast.show('success', 'Exportação Concluída', `Arquivo ${arrayName}.h gerado com sucesso.`);
    }

    _setupTools() {
        const tools = ['brush', 'eraser', 'selection', 'move', 'text', 'line', 'rect', 'circle', 'picker', 'fill', 'font-gen', 'clear'];
        tools.forEach(k => {
            const btn = this.dom('tool-' + k);
            if (btn) btn.onclick = async () => {
                this.currentTool = k;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (k === 'clear') { if (await this.dialog.confirm('Limpar Tudo', 'Limpar todo o canvas?')) this.init(true); }
                if (k === 'font-gen') { this.toast.show('success', 'Font Generator', 'Recurso de exportação de fonte ativado.'); }
            };
        });
        const aiBtn = this.dom('tool-ai-gen');
        if (aiBtn) aiBtn.onclick = () => { this.dom('ai-modal').style.display = 'flex'; if (typeof lucide !== 'undefined') lucide.createIcons(); };
        document.querySelectorAll('textarea').forEach(tx => {
            tx.onkeydown = (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault(); const s = tx.selectionStart;
                    tx.value = tx.value.substring(0, s) + '    ' + tx.value.substring(tx.selectionEnd);
                    tx.selectionStart = tx.selectionEnd = s + 4;
                }
            };
        });
    }

    refresh() {
        const pCtx = this.dom('preview-canvas')?.getContext('2d');
        if (pCtx) {
            pCtx.clearRect(0, 0, pCtx.canvas.width, pCtx.canvas.height);
            this.layers.layers.forEach(l => { if (l.visible) pCtx.drawImage(l.canvas, 0, 0); });
        }
        if (this.layout) { this.layout.updateRulers(); this.layout.renderGrid(); }
        if (this.layers) this.layers.renderUI();
    }

    saveHistory() {
        const snap = this.layers.layers.map(l => ({ name: l.name, data: l.canvas.toDataURL(), visible: l.visible }));
        this.undoStack.push(JSON.stringify(snap));
        if (this.undoStack.length > this.MAX_HISTORY) this.undoStack.shift();
        this.redoStack = [];
    }

    undo() {
        if (this.undoStack.length < 2) return;
        this.redoStack.push(this.undoStack.pop());
        const snap = JSON.parse(this.undoStack[this.undoStack.length - 1]);
        this._applySnapshot(snap);
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const snapStr = this.redoStack.pop();
        this.undoStack.push(snapStr);
        this._applySnapshot(JSON.parse(snapStr));
    }

    _applySnapshot(snap) {
        this.layers.layers.forEach(l => l.canvas.remove());
        this.layers.layers = [];
        snap.forEach((d, i) => {
            this.layers.add(d.name, d.data, true);
            this.layers.layers[i].visible = d.visible;
            this.layers.layers[i].canvas.style.display = d.visible ? 'block' : 'none';
        });
        this.refresh();
    }

    start() {
        try {
            this.init();
            this.nav.switch('design');
            this.prototype.init(this);
            this.stage.refresh();
            console.log("App Started Successfully");
        } catch (e) { console.error("Crash during launch:", e); }
    }
}

// TFTSimulator removed by user request. All simulation logic has been cleared.

// ========== 9. Manager Classes ==========
class DialogManager extends EditorModule {
    _open(title, msg, iconSvg, opts = {}) {
        return new Promise((r) => {
            const m = this.dom('custom-dialog'); if (!m) return r(null);
            this.dom('dialog-title').textContent = title;
            this.dom('dialog-message').textContent = msg;
            this.dom('dialog-icon').innerHTML = iconSvg;
            this.dom('dialog-input').style.display = opts.showInput ? 'block' : 'none';
            this.dom('dialog-confirm').textContent = opts.confirmText || 'OK';
            m.style.display = 'flex';
            this.dom('dialog-confirm').onclick = () => { m.style.display = 'none'; r(opts.showInput ? this.dom('dialog-input').value : true); };
            this.dom('dialog-cancel').onclick = () => { m.style.display = 'none'; r(null); };
        });
    }
    confirm(t, m) { return this._open(t, m, '', { showCancel: true }); }
    prompt(t, m, d) { return this._open(t, m, '', { showInput: true, defaultValue: d }); }
}

class ToastManager extends EditorModule {
    show(type, title, msg) {
        const c = (type === 'error') ? this.dom('toast-error-container') : this.dom('toast-success-container');
        if (!c) return;
        const t = document.createElement('div');
        t.className = `toast toast-${type}`;
        t.innerHTML = `<b>${title}</b><p>${msg}</p>`;
        c.appendChild(t);
        setTimeout(() => t.remove(), 3000);
    }
}

class StatusBarManager extends EditorModule {
    update(v) {
        if (this.dom('status-view')) this.dom('status-view').textContent = v;
        if (this.dom('status-time')) this.dom('status-time').textContent = new Date().toLocaleTimeString();
    }
}

class StageManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.endpoint = '/api/stage';
        this.files = [];
    }

    async refresh() {
        try {
            const resp = await this.app.api.request(this.endpoint);
            if (!resp.ok) throw new Error('Failed to fetch stage');
            this.files = await resp.json();
            this.render();
        } catch (e) {
            console.error("Error refreshing stage:", e);
        }
    }

    async save(filename, content) {
        try {
            const resp = await this.app.api.request(`${this.endpoint}/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename, content })
            });
            if (!resp.ok) throw new Error('Save failed');
            this.app.toast.show('success', 'Stage Guardado', `Arquivo ${filename} salvo no micro-stage.`);
            this.refresh();
        } catch (e) {
            this.app.toast.show('error', 'Erro ao Salvar', 'Não foi possível salvar no stage.');
        }
    }

    async delete(filename) {
        if (!await this.app.dialog.confirm('Excluir Arquivo', `Deseja remover ${filename} do stage?`)) return;
        try {
            const resp = await this.app.api.request(`${this.endpoint}/${filename}`, { method: 'DELETE' });
            if (!resp.ok) throw new Error('Delete failed');
            this.refresh();
        } catch (e) {
            this.app.toast.show('error', 'Erro ao Excluir', 'Falha ao remover arquivo.');
        }
    }

    render() {
        const list = this.dom('stage-file-list');
        if (!list) return;
        list.innerHTML = '';
        if (this.files.length === 0) {
            list.innerHTML = '<div class="hint">Stage vazio.</div>';
            return;
        }
        this.files.forEach(f => {
            const item = document.createElement('div');
            item.className = 'layer-item';
            item.style.fontSize = '0.7rem';
            item.innerHTML = `
                <i data-lucide="${f.name.endsWith('.h') ? 'file-code' : 'image'}" style="width:12px;"></i>
                <span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${f.name}</span>
                <span style="opacity:0.5; margin-right:4px;">${(f.size / 1024).toFixed(1)}K</span>
                <button class="action-btn delete-file" title="Excluir"><i data-lucide="trash-2"></i></button>
            `;
            item.querySelector('.delete-file').onclick = (e) => { e.stopPropagation(); this.delete(f.name); };
            item.onclick = () => {
                // Se for imagem, pode importar como background
                if (f.name.match(/\.(jpg|jpeg|png|bmp)$/i)) {
                    const url = `/stage/${f.name}`;
                    this.app.prototype.screens[this.app.prototype.activeIndex].background = url;
                    this.app.prototype.refresh();
                }
            };
            list.appendChild(item);
        });
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

class ApiClient extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.tokenKey = 'pixelstream_jwt';
        this.accessKeyKey = 'pixelstream_access_key';
        this.tokenEndpoint = '/api/auth/token';
    }

    setAccessKey(key) {
        localStorage.setItem(this.accessKeyKey, key);
        localStorage.removeItem(this.tokenKey);
    }

    getAccessKey() {
        return localStorage.getItem(this.accessKeyKey) || '';
    }

    _getToken() {
        return localStorage.getItem(this.tokenKey) || '';
    }

    _isTokenValid(token) {
        try {
            const payload = JSON.parse(atob(token.split('.')[1] || ''));
            const exp = payload.exp ? payload.exp * 1000 : 0;
            return exp > Date.now() + 60000;
        } catch {
            return false;
        }
    }

    async _fetchToken() {
        const resp = await fetch(this.tokenEndpoint, { method: 'GET' });
        if (!resp.ok) throw new Error('token_failed');
        const data = await resp.json();
        if (data?.token) {
            localStorage.setItem(this.tokenKey, data.token);
            return data.token;
        }
        throw new Error('token_invalid');
    }

    async ensureToken() {
        const token = this._getToken();
        if (token && this._isTokenValid(token)) return token;
        return this._fetchToken();
    }

    async request(url, options = {}) {
        try {
            const token = await this.ensureToken();
            const headers = new Headers(options.headers || {});
            headers.set('Authorization', `Bearer ${token}`);
            return fetch(url, { ...options, headers });
        } catch (e) {
            if (e.message === 'missing_access_key') {
                this.app.toast.show('error', 'Auth', 'Configure a Chave de Acesso API.');
            } else {
                this.app.toast.show('error', 'Auth', 'Falha ao autenticar na API.');
            }
            throw e;
        }
    }
}

class AgentConfigManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.endpoint = '/api/agents';
        this._bindUI();
    }

    _bindUI() {
        const btnOpen = this.dom('btn-agent-config');
        if (btnOpen) btnOpen.onclick = () => this.open();

        const btnClose = this.dom('btn-agent-close');
        if (btnClose) btnClose.onclick = () => this.close();

        const btnSave = this.dom('btn-agent-save');
        if (btnSave) btnSave.onclick = () => this.save();
    }

    async open() {
        this.load();
        if (this.dom('agent-modal')) this.dom('agent-modal').style.display = 'flex';
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    close() {
        if (this.dom('agent-modal')) this.dom('agent-modal').style.display = 'none';
    }

    async load() {
        try {
            const accessKey = localStorage.getItem('pixelstream_access_key') || '';
            if (this.dom('agent-access-key')) this.dom('agent-access-key').value = accessKey;

            const resp = await this.app.api.request(this.endpoint, { cache: 'no-store' });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const key = data?.gemini?.apiKey || '';
            if (this.dom('agent-gemini-key')) this.dom('agent-gemini-key').value = key;
        } catch (e) {
            this.app.toast.show('warning', 'Aviso', 'Nao foi possivel carregar as chaves.');
        }
    }

    async save() {
        const accessKey = this.dom('agent-access-key')?.value.trim() || '';
        const geminiKey = this.dom('agent-gemini-key')?.value.trim() || '';

        try {
            this.app.api.setAccessKey(accessKey);
            const resp = await this.app.api.request(this.endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ Gemini: { ApiKey: geminiKey } })
            });
            if (resp.ok) {
                this.app.toast.show('success', 'Configuração Salva', 'Chave criptografada no sistema principal.');
                this.close();
            }
        } catch (e) {
            this.app.toast.show('error', 'Erro', 'Falha ao salvar as chaves.');
        }
    }

    getKey() {
        return this.dom('agent-gemini-key')?.value || '';
    }
}

class LogManager extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.logs = JSON.parse(localStorage.getItem('pixelstream_logs') || '[]');
        this._setupGlobalErrors();
    }

    _setupGlobalErrors() {
        window.onerror = (msg, url, line, col, error) => {
            this.error('Global', `${msg} at ${line}:${col}`, { url, stack: error?.stack });
        };
        window.onunhandledrejection = (event) => {
            this.error('Promise', event.reason?.message || 'Unhandled Rejection', { stack: event.reason?.stack });
        };
    }

    error(context, message, data = {}) {
        const entry = {
            timestamp: new Date().toISOString(),
            type: 'ERROR',
            context,
            message,
            data
        };
        this.logs.push(entry);
        if (this.logs.length > 100) this.logs.shift(); // Keep last 100
        localStorage.setItem('pixelstream_logs', JSON.stringify(this.logs));
        console.error(`[${context}] ${message}`, data);
        this._sendToServer(entry);
    }

    _sendToServer(entry) {
        if (!this.app.api) return;
        this.app.api.request('/api/logs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                Context: entry.context,
                Type: entry.type,
                Message: entry.message,
                Data: entry.data
            })
        }).catch(() => { });
    }

    exportLogs() {
        if (this.logs.length === 0) return this.app.toast.show('info', 'Logs Vazios', 'Nenhum erro registrado até agora.');
        const content = this.logs.map(l => `[${l.timestamp}] [${l.context}] ${l.type}: ${l.message}\nData: ${JSON.stringify(l.data, null, 2)}\`---\``).join('\n\n');
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `error_${new Date().getTime()}.log`;
        a.click();
        URL.revokeObjectURL(url);
        this.app.toast.show('success', 'Logs Exportados', 'Arquivo de log baixado com sucesso.');
    }

    clear() {
        this.logs = [];
        localStorage.removeItem('pixelstream_logs');
    }
}

class AIPixelArtGenerator extends EditorModule {
    constructor(app) {
        super();
        this.app = app;
        this.palettes = {
            2: [[15, 56, 15], [155, 188, 15]],
            4: [[15, 56, 15], [48, 98, 48], [139, 172, 15], [155, 188, 15]],
            8: [[0, 0, 0], [255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255], [0, 255, 255], [255, 255, 255]],
            16: [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0], [0, 0, 128], [128, 0, 128], [0, 128, 128], [192, 192, 192], [128, 128, 128], [255, 0, 0], [0, 255, 0], [255, 255, 0], [0, 0, 255], [255, 0, 255], [0, 255, 255], [255, 255, 255]]
        };
    }

    async generate() {
        const promptInput = this.dom('ai-prompt');
        const prompt = promptInput ? promptInput.value.trim() : '';
        if (!prompt) return this.app.toast.show('warning', 'Prompt vazio', 'Descreva o que deseja gerar.');

        this._setLoading(true);
        const seed = Math.floor(Math.random() * 1e6);

        try {
            // Chama a API unificada do Servidor C#
            const params = new URLSearchParams({ prompt, seed });
            const resp = await this.app.api.request(`/api/ai/image?${params.toString()}`);

            if (!resp.ok) {
                const errData = await resp.json().catch(() => ({}));
                throw new Error(errData.body || `HTTP ${resp.status}`);
            }

            const blob = await resp.blob();
            const img = await this._loadBlobImage(blob);
            this._displayPreview(img);
        } catch (e) {
            this.app.logger.error('AIGenerator', 'Falha na geração via Servidor', { prompt, seed, error: e.message });
            const msg = e.message.includes('Quota exceeded')
                ? 'Quota de imagens excedida. Verifique seu plano/billing.'
                : 'Falha ao gerar imagem pelo servidor principal.';
            this._handleError(msg);
        }
        this._setLoading(false);
    }

    _loadBlobImage(blob) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const objectUrl = URL.createObjectURL(blob);
            img.onload = () => { URL.revokeObjectURL(objectUrl); resolve(img); };
            img.onerror = () => { URL.revokeObjectURL(objectUrl); reject(new Error("Erro ao decodificar imagem do servidor")); };
            img.src = objectUrl;
        });
    }

    _displayPreview(img) {
        const canvas = this.dom('ai-preview-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const pixelSize = parseInt(this.dom('ai-pixel-size')?.value) || 1;
        if (pixelSize > 1) {
            const temp = document.createElement('canvas');
            temp.width = 240 / pixelSize; temp.height = 240 / pixelSize;
            temp.getContext('2d').drawImage(img, 0, 0, temp.width, temp.height);
            ctx.clearRect(0, 0, 240, 240);
            ctx.drawImage(temp, 0, 0, 240, 240);
        } else {
            ctx.drawImage(img, 0, 0, 240, 240);
        }

        const mode = this.dom('ai-palette')?.value;
        if (mode && mode !== 'full') {
            try {
                this._reduce(ctx, parseInt(mode) || 16);
            } catch (e) {
                this.app.toast.show('warning', 'Aviso de Segurança', 'A imagem foi carregada, mas o navegador bloqueou a leitura de pixels (CORS). A redução de paleta foi ignorada.');
            }
        }

        if (this.dom('ai-preview')) this.dom('ai-preview').style.display = 'block';
        if (this.dom('btn-ai-apply')) this.dom('btn-ai-apply').style.display = 'inline-flex';
    }

    _handleError(msg) {
        const isLocal = window.location.protocol === 'file:';
        const advice = isLocal ? "\n\nDica: Você está usando o protocolo 'file:'. Use o Live Server do VS Code para evitar bloqueios do navegador." : "";
        this.app.toast.show('error', 'Erro de Geração', msg + advice);
    }

    _reduce(ctx, n) {
        const id = ctx.getImageData(0, 0, 240, 240);
        const d = id.data, p = this.palettes[n];
        for (let i = 0; i < d.length; i += 4) {
            let m = Infinity, b = p[0];
            for (const c of p) { const dist = (d[i] - c[0]) ** 2 + (d[i + 1] - c[1]) ** 2 + (d[i + 2] - c[2]) ** 2; if (dist < m) { m = dist; b = c; } }
            d[i] = b[0]; d[i + 1] = b[1]; d[i + 2] = b[2];
        }
        ctx.putImageData(id, 0, 0);
    }

    apply() {
        const layer = this.app.layers.active;
        if (layer) {
            try {
                layer.ctx.drawImage(this.dom('ai-preview-canvas'), 0, 0);
                this.app.refresh();
                this.app.saveHistory();
            } catch (e) {
                this.app.logger.error('AIGenerator', 'Erro ao aplicar imagem ao canvas (CORS)', { error: e.message });
                this.app.toast.show('error', 'Erro de Segurança', 'Não foi possível aplicar a imagem ao canvas devido a restrições de segurança do navegador (CORS).');
            }
        }
        this.dom('ai-modal').style.display = 'none';
    }

    _setLoading(on) {
        if (this.dom('ai-loading')) this.dom('ai-loading').style.display = on ? 'block' : 'none';
        if (this.dom('btn-ai-generate')) this.dom('btn-ai-generate').disabled = on;
    }
}
