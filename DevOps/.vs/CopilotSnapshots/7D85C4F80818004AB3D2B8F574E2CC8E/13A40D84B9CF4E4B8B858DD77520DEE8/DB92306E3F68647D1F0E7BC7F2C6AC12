/**
 * Prototype View - Handles DOM manipulation, canvas rendering, and TFT code parsing.
 */
class PrototypeView {
    constructor(apiClient) {
        this.api = apiClient;
        this.stage = null; // set via setApiClient()
        this.dom = {
            screenList: document.getElementById('screen-list'),
            mainGallery: document.getElementById('proto-main-container'),
            canvas: document.getElementById('proto-canvas'),
            assetList: document.getElementById('proto-asset-list'),
            codePreview: document.getElementById('proto-code-preview'),
            elementList: document.getElementById('proto-element-list'),
            interactionPanel: document.getElementById('proto-interaction-panel'),
            fileList: document.getElementById('stage-file-list'),
            addScreenBtn: document.getElementById('btn-add-screen'),
            addRectBtn: document.getElementById('btn-add-rect'),
            addCircleBtn: document.getElementById('btn-add-circle'),
            uploadAssetBtn: document.getElementById('btn-upload-asset'),
            assetInput: document.getElementById('proto-asset-upload')
        };

        if (this.dom.canvas) {
            this.ctx = this.dom.canvas.getContext('2d');
            this.setupCanvasEvents();
        }

        // Wire code editor → live canvas preview + debounced model sync
        if (this.dom.codePreview) {
            this.dom.codePreview.oninput = () => {
                this._codeEditedManually = true;
                this.parseAndRenderCode(this.dom.codePreview.value);
                // Debounce: after 800ms of no typing, sync code back to model
                clearTimeout(this._codeSyncTimer);
                this._codeSyncTimer = setTimeout(() => {
                    this.onCodeChanged?.(this.dom.codePreview.value);
                }, 800);
            };
        }

        this.setupGeneralEvents();
        this.imageCache = new Map();
        this._bgImage = null;
        this._codeEditedManually = false;

        // TFT Named Color constants (RGB565)
        this._tftColors = {
            TFT_BLACK: 0x0000, TFT_NAVY: 0x000F, TFT_DARKGREEN: 0x03E0,
            TFT_DARKCYAN: 0x03EF, TFT_MAROON: 0x7800, TFT_PURPLE: 0x780F,
            TFT_OLIVE: 0x7BE0, TFT_LIGHTGREY: 0xC618, TFT_DARKGREY: 0x7BEF,
            TFT_BLUE: 0x001F, TFT_GREEN: 0x07E0, TFT_CYAN: 0x07FF,
            TFT_RED: 0xF800, TFT_MAGENTA: 0xF81F, TFT_YELLOW: 0xFFE0,
            TFT_WHITE: 0xFFFF, TFT_ORANGE: 0xFDA0, TFT_GREENYELLOW: 0xB7E0,
            TFT_PINK: 0xFE19, TFT_BROWN: 0x9A60, TFT_GOLD: 0xFEA0,
            TFT_SILVER: 0xC618, TFT_SKYBLUE: 0x867D, TFT_VIOLET: 0x915C
        };
    }

    /** Called by PrototypeController after api is ready */
    setApiClient(apiClient) {
        this.stage = new ProtoStageManager(apiClient);
        this._wireStageEvents();
    }

    setupCanvasEvents() {
        this.dom.canvas.onmousedown = (e) => this.onCanvasMouseDown?.(e);
        this.dom.canvas.onmousemove = (e) => this.onCanvasMouseMove?.(e);
        this.dom.canvas.onmouseup = (e) => this.onCanvasMouseUp?.(e);
    }

    setupGeneralEvents() {
        if (this.dom.addScreenBtn) this.dom.addScreenBtn.onclick = () => this.onAddScreen?.();
        if (this.dom.addRectBtn) this.dom.addRectBtn.onclick = () => this.onAddElement?.('rect');
        if (this.dom.addCircleBtn) this.dom.addCircleBtn.onclick = () => this.onAddElement?.('circle');
        if (this.dom.uploadAssetBtn) this.dom.uploadAssetBtn.onclick = () => this.dom.assetInput?.click();

        // Generic asset upload
        if (this.dom.assetInput) {
            this.dom.assetInput.onchange = async (e) => {
                for (const file of e.target.files) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        this.onAssetUpload?.({ name: file.name, dataUrl: ev.target.result, kind: 'image' });
                    };
                    reader.readAsDataURL(file);
                }
            };
        }

        // JPG / BMP / PNG import → set as background
        const imgBtn = document.getElementById('btn-upload-image');
        const imgInput = document.getElementById('proto-image-upload');
        if (imgBtn && imgInput) imgBtn.onclick = () => imgInput.click();
        if (imgInput) {
            imgInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => this._handleImageImport(file.name, ev.target.result);
                reader.readAsDataURL(file);
                imgInput.value = '';
            };
        }

        // .h C-array import → parse RGB565 → background
        const hBtn = document.getElementById('btn-upload-h');
        const hInput = document.getElementById('proto-h-upload');
        if (hBtn && hInput) hBtn.onclick = () => hInput.click();
        if (hInput) {
            hInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => this._handleHImport(file.name, ev.target.result);
                reader.readAsText(file);
                hInput.value = '';
            };
        }

        // ── TFT Command Builder ────────────────────────────────────────────
        this._cmdBuilder = new TFTCommandBuilder((codeLine) => {
            // Insert at cursor in the textarea, then trigger sync
            const ta = this.dom.codePreview;
            if (!ta) return;

            const pos = ta.selectionEnd;
            const before = ta.value.slice(0, pos);
            const after = ta.value.slice(pos);
            // Insert after the current line
            const lineEnd = before.lastIndexOf('\n') + 1;
            const lineStart = before.lastIndexOf('\n', pos - 1) + 1;
            // Find end of current line
            const currentLineEnd = ta.value.indexOf('\n', pos);
            const insertAt = currentLineEnd === -1 ? ta.value.length : currentLineEnd;

            ta.value = ta.value.slice(0, insertAt) + '\n' + codeLine + ta.value.slice(insertAt);
            // Move cursor after inserted line
            ta.selectionStart = ta.selectionEnd = insertAt + codeLine.length + 1;
            ta.focus();

            // Trigger live preview + debounced model sync
            this._codeEditedManually = true;
            this.parseAndRenderCode(ta.value);
            clearTimeout(this._codeSyncTimer);
            this._codeSyncTimer = setTimeout(() => {
                this.onCodeChanged?.(ta.value);
            }, 800);
        });

        // Wire all TFT command buttons
        document.querySelectorAll('.tft-cmd-btn').forEach(btn => {
            btn.onclick = () => {
                const cmdId = btn.dataset.cmd;
                if (cmdId) this._cmdBuilder.show(cmdId);
            };
        });
    }

    /** Wire Stage-specific events (called after api is ready) */
    _wireStageEvents() {
        // Refresh Stage list
        const btnRefresh = document.getElementById('btn-refresh-stage');
        if (btnRefresh) btnRefresh.onclick = () => this._loadStageList();

        // Save code to Stage
        const btnSaveCode = document.getElementById('btn-save-code-stage');
        if (btnSaveCode) btnSaveCode.onclick = () => {
            const code = this.dom.codePreview?.value || '';
            this.stage.saveCppFile('pixelstream_v5', code).then(ok => {
                const toast = window.app?.toast;
                if (toast) toast.show(ok ? 'success' : 'error', ok ? 'Código salvo no Stage!' : 'Falha ao salvar');
            });
        };

        // Stage file list: clicking a file uses it
        if (this.stage) {
            this.stage.onFileSelect = (f) => this._onStageFileSelected(f);
        }

        // Initial load
        this._loadStageList();
    }

    async _loadStageList() {
        if (!this.stage) return;
        const container = document.getElementById('stage-file-list');
        await this.stage.renderFileList(container);
    }

    /** Handle JPG/BMP/PNG imported from disk → set as screen background + save to Stage */
    async _handleImageImport(filename, dataUrl) {
        // Set as active screen background via callback
        this.onImportBackground?.(dataUrl, filename);

        // Update proto canvas immediately
        const img = new Image();
        img.onload = () => {
            this._bgImage = img;
            const ctx = this.ctx;
            if (ctx) {
                ctx.clearRect(0, 0, 240, 240);
                ctx.drawImage(img, 0, 0, 240, 240);
            }
        };
        img.src = dataUrl;

        // Auto-save to Stage
        if (this.stage) {
            await this.stage.saveImage(filename, dataUrl);
            await this._loadStageList();
            const toast = window.app?.toast;
            if (toast) toast.show('success', 'Imagem importada!', `${filename} salvo no Stage e carregado como fundo.`);
        }
    }

    /** Handle .h C-array → parse RGB565 → render + save to Stage */
    async _handleHImport(filename, content) {
        if (!this.stage) {
            console.warn('[Proto] Stage not ready for .h import');
            return;
        }

        const parsed = this.stage.parseHFile(content);
        if (!parsed) {
            const toast = window.app?.toast;
            if (toast) toast.show('error', 'Erro ao parsear .h', 'Nenhum array uint16_t encontrado.');
            return;
        }

        const dataUrl = this.stage.hArrayToDataUrl(parsed);

        // Show info
        const info = document.getElementById('h-import-info');
        if (info) {
            info.style.display = 'block';
            info.textContent = `${parsed.name} [${parsed.width}×${parsed.height}] — ${parsed.pixels.length} px`;
        }

        // Set as background
        this.onImportBackground?.(dataUrl, parsed.name);

        // Render on canvas
        const img = new Image();
        img.onload = () => {
            this._bgImage = img;
            const ctx = this.ctx;
            if (ctx) { ctx.clearRect(0, 0, 240, 240); ctx.drawImage(img, 0, 0, 240, 240); }
        };
        img.src = dataUrl;

        // Save the original .h AND the rendered PNG to Stage
        await this.stage.saveHFile(filename, content);
        await this.stage.saveImage(parsed.name + '_preview', dataUrl);
        await this._loadStageList();

        const toast = window.app?.toast;
        if (toast) toast.show('success', 'Array .h importado!',
            `${parsed.name} (${parsed.width}×${parsed.height}) carregado. Arquivo salvo no Stage.`);
    }

    /** When user clicks a Stage file — load it into the prototype */
    async _onStageFileSelected(file) {
        const name = file.name;
        const ext = name.split('.').pop().toLowerCase();

        // Fetch the file from the Stage static path
        const url = `/stage/${name}`; // served as static

        if (ext === 'h') {
            const resp = await fetch(url);
            const text = await resp.text();
            await this._handleHImport(name, text);
        } else if (['png', 'jpg', 'jpeg', 'bmp'].includes(ext)) {
            // Convert to dataURL
            const resp = await fetch(url);
            const blob = await resp.blob();
            const reader = new FileReader();
            reader.onload = (ev) => this._handleImageImport(name, ev.target.result);
            reader.readAsDataURL(blob);
        } else if (ext === 'cpp' || ext === 'ino') {
            const resp = await fetch(url);
            const text = await resp.text();
            if (this.dom.codePreview) {
                this.dom.codePreview.value = text;
                this._codeEditedManually = true;
                this.parseAndRenderCode(text);
            }
        }
    }

    render(model) {
        this.renderScreenList(model);
        this.renderMainGallery(model);
        this.renderAssetList(model);
        this.renderWorkspace(model);     // ALWAYS draw model to canvas
        this.renderElementList(model);
        this.renderCodePreview(model);   // ALWAYS regenerate C++ code from model
        this.renderInspector(model);

        const title = document.getElementById('active-screen-title');
        if (title && model.activeScreen) {
            title.textContent = model.activeScreen.name;
        }
    }

    // ─── Screen List ───────────────────────────────────────────────────────────
    renderScreenList(model) {
        if (!this.dom.screenList) return;
        this.dom.screenList.innerHTML = '';

        model.screens.forEach(screen => {
            const isActive = screen.id === model.activeScreenId;
            const item = document.createElement('div');
            item.className = `layer-item ${isActive ? 'active' : ''}`;
            item.onclick = () => {
                this._codeEditedManually = false; // reset on screen switch
                this.onSelectScreen?.(screen.id);
            };
            item.innerHTML = `
                <i data-lucide="monitor" style="width:14px;"></i>
                <span class="screen-name" style="flex:1;">${screen.name}</span>
                <button class="action-btn delete-screen" title="Excluir"><i data-lucide="trash-2"></i></button>
            `;
            const delBtn = item.querySelector('.delete-screen');
            delBtn.onclick = (e) => { e.stopPropagation(); this.onDeleteScreen?.(screen.id); };
            this.dom.screenList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Main Gallery ──────────────────────────────────────────────────────────
    renderMainGallery(model) {
        if (!this.dom.mainGallery) return;
        this.dom.mainGallery.innerHTML = '';

        model.screens.forEach(screen => {
            const isActive = screen.id === model.activeScreenId;
            const card = document.createElement('div');
            card.className = `screen-card ${isActive ? 'active' : ''}`;
            card.onclick = () => this.onSelectScreen?.(screen.id);
            card.style.cssText = `
                display: flex; flex-direction: column; padding: 12px; gap: 8px;
                width: 220px;
                background: ${isActive ? 'rgba(56, 189, 248, 0.1)' : 'var(--card-bg)'};
                border: ${isActive ? '2px solid var(--primary)' : '1px solid var(--border)'};
                border-radius: 12px; cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s; position: relative;
            `;
            const title = document.createElement('div');
            title.style.cssText = 'font-size: 0.65rem; font-weight: 800; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;';
            title.textContent = screen.name;

            const canvas = document.createElement('canvas');
            canvas.width = 240; canvas.height = 240;
            canvas.style.cssText = 'width: 100%; height: auto; background: #000; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';

            card.appendChild(title);
            card.appendChild(canvas);
            this.dom.mainGallery.appendChild(card);
            this._drawToCanvas(screen, canvas, model.assets);
        });
    }

    // ─── Workspace (Active Screen Canvas) ──────────────────────────────────────
    renderWorkspace(model) {
        if (!this.dom.canvas || !model.activeScreen) return;
        // Always draw from model — textarea parser is a separate real-time overlay
        this._drawToCanvas(model.activeScreen, this.dom.canvas, model.assets);
    }

    _drawToCanvas(screen, canvas, assets) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background: either a dataURL (from designer import) or asset name
        if (screen.background) {
            const img = this._getImg(screen.background);
            if (img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                // Keep reference for code parser pushImage
                if (canvas === this.dom.canvas) this._bgImage = img;
            } else {
                img.onload = () => {
                    if (canvas === this.dom.canvas) this._bgImage = img;
                    this._drawToCanvas(screen, canvas, assets);
                };
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (canvas === this.dom.canvas) this._bgImage = null;
        }

        // Elements
        screen.elements.forEach(el => {
            ctx.save();
            if (el.asset) {
                const asset = assets.find(a => a.name === el.asset);
                if (asset) {
                    const img = this._getImg(asset.dataUrl);
                    if (img.complete) {
                        ctx.drawImage(img, el.x, el.y, el.w, el.h);
                    } else {
                        img.onload = () => this._drawToCanvas(screen, canvas, assets);
                    }
                }
            } else {
                ctx.fillStyle = el.color || '#38bdf8';
                if (el.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(el.x + el.w / 2, el.y + el.h / 2, el.w / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(el.x, el.y, el.w, el.h);
                }
            }
            ctx.restore();
        });
    }

    _getImg(dataUrl) {
        if (this.imageCache.has(dataUrl)) return this.imageCache.get(dataUrl);
        const img = new Image();
        img.src = dataUrl;
        this.imageCache.set(dataUrl, img);
        return img;
    }

    // ─── Asset List ────────────────────────────────────────────────────────────
    renderAssetList(model) {
        if (!this.dom.assetList) return;
        this.dom.assetList.innerHTML = '';

        if (model.assets.length === 0) {
            this.dom.assetList.innerHTML = '<div class="hint" style="grid-column: 1/-1;">Sem assets</div>';
            return;
        }

        model.assets.forEach(asset => {
            const item = document.createElement('div');
            item.className = 'asset-item';
            item.style.cssText = 'background: var(--bg-dark); border: 1px solid var(--border); border-radius: 8px; padding: 6px; display: flex; flex-direction: column; gap: 4px;';
            item.innerHTML = `
                <img src="${asset.dataUrl}" style="width: 100%; height: 40px; object-fit: contain; background: #000; border-radius: 4px;">
                <div style="font-size: 0.6rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: center;">${asset.name}</div>
                <div style="display: flex; gap: 2px;">
                    <button class="small-btn bg-btn" title="Fundo"><i data-lucide="monitor" style="width:10px;"></i></button>
                    <button class="small-btn add-btn" title="Add"><i data-lucide="plus" style="width:10px;"></i></button>
                    <button class="small-btn del-btn" title="Apagar"><i data-lucide="trash-2" style="width:10px;"></i></button>
                </div>
            `;
            item.querySelector('.bg-btn').onclick = (e) => { e.stopPropagation(); this.onPropertyChange?.(null, 'background', asset.name); };
            item.querySelector('.add-btn').onclick = (e) => { e.stopPropagation(); this.onAddElement?.('image', asset.name); };
            item.querySelector('.del-btn').onclick = (e) => { e.stopPropagation(); this.onDeleteAsset?.(asset.name); };
            this.dom.assetList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Element List ──────────────────────────────────────────────────────────
    renderElementList(model) {
        if (!this.dom.elementList || !model.activeScreen) return;
        this.dom.elementList.innerHTML = '';

        model.activeScreen.elements.forEach(el => {
            const isActive = el.id === model.selectedElementId;
            const item = document.createElement('div');
            item.className = `layer-item ${isActive ? 'active' : ''}`;
            item.onclick = () => this.onSelectElement?.(el.id);
            item.innerHTML = `
                <i data-lucide="${el.asset ? 'image' : 'square'}" style="width:12px;"></i>
                <span style="flex:1;">${el.name}</span>
                <button class="action-btn del-el" title="Remover"><i data-lucide="trash-2" style="width:12px;"></i></button>
            `;
            item.querySelector('.del-el').onclick = (e) => { e.stopPropagation(); this.onElementDelete?.(el.id); };
            this.dom.elementList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Code Preview (Auto-generated + Editable) ─────────────────────────────
    renderCodePreview(model) {
        if (!this.dom.codePreview) return;

        let code = '// PixelStream v5 - Auto-generated Code\n';
        code += '// Edit freely — changes reflect in the display preview in real time.\n';
        code += '#include <TFT_eSPI.h>\n';
        code += '#include <SPI.h>\n';
        code += 'extern TFT_eSPI tft;\n\n';

        model.screens.forEach(screen => {
            const fnName = screen.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');

            // If screen has a design background (dataURL), reference it as an image array
            if (screen.background && screen.background.startsWith('data:')) {
                const arrName = `${fnName}_bg`;
                code += `// NOTE: Export "${fnName}" from the Designer as a C array named "${arrName}"\n`;
                code += `// extern const uint16_t ${arrName}[] PROGMEM;\n\n`;
            }

            code += `void draw_${fnName}() {\n`;

            if (screen.background && screen.background.startsWith('data:')) {
                code += `  tft.pushImage(0, 0, 240, 240, ${fnName}_bg);\n`;
            } else if (screen.backgroundAsset) {
                code += `  tft.pushImage(0, 0, 240, 240, ${screen.backgroundAsset});\n`;
            } else {
                code += `  tft.fillScreen(TFT_BLACK);\n`;
            }

            screen.elements.forEach(el => {
                if (el.asset) {
                    code += `  tft.pushImage(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${el.asset});\n`;
                } else if (el.type === 'circle') {
                    const cx = Math.round(el.x + el.w / 2);
                    const cy = Math.round(el.y + el.h / 2);
                    const r = Math.round(el.w / 2);
                    code += `  tft.fillCircle(${cx}, ${cy}, ${r}, ${this.hexTo565(el.color)}); // ${el.name}\n`;
                } else {
                    code += `  tft.fillRect(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${this.hexTo565(el.color)}); // ${el.name}\n`;
                }
            });

            code += '}\n\n';
        });

        this.dom.codePreview.value = code;
    }

    hexTo565(hex) {
        if (!hex) return '0x0000';
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const rgb565 = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
        return '0x' + rgb565.toString(16).toUpperCase().padStart(4, '0');
    }

    /** Convert RGB565 integer back to hex color string */
    _rgb565ToHex(c) {
        const r = Math.round(((c >> 11) & 0x1F) * 255 / 31);
        const g = Math.round(((c >> 5) & 0x3F) * 255 / 63);
        const b = Math.round((c & 0x1F) * 255 / 31);
        return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Parse the active screen's function from C++ code and extract elements.
     * Returns [{type, x, y, w, h, color}]
     */
    _parseElementsFromCode(code, fnName) {
        const elements = [];
        // Extract just the body of the active screen function
        const fnRe = new RegExp(`void\\s+draw_${fnName}\\s*\\([^)]*\\)\\s*\\{([\\s\\S]*?)\\}`);
        const fnMatch = code.match(fnRe);
        const body = fnMatch ? fnMatch[1] : code;

        for (const line of body.split('\n')) {
            const trimmed = line.trim();
            // fillRect(x, y, w, h, color)
            const rm = trimmed.match(/tft\.fillRect\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (rm) {
                elements.push({
                    type: 'rect',
                    x: parseInt(rm[1]), y: parseInt(rm[2]),
                    w: parseInt(rm[3]), h: parseInt(rm[4]),
                    color: this._rgb565ToHex(parseInt(rm[5], rm[5].startsWith('0x') || rm[5].startsWith('0X') ? 16 : 10))
                });
                continue;
            }
            // fillCircle(cx, cy, r, color) → convert to x,y,w,h bounding box
            const cm = trimmed.match(/tft\.fillCircle\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (cm) {
                const cx = parseInt(cm[1]), cy = parseInt(cm[2]), r = parseInt(cm[3]);
                elements.push({
                    type: 'circle',
                    x: cx - r, y: cy - r, w: r * 2, h: r * 2,
                    color: this._rgb565ToHex(parseInt(cm[4], cm[4].startsWith('0x') || cm[4].startsWith('0X') ? 16 : 10))
                });
            }
        }
        return elements;
    }

    // ─── TFT Code Parser → Live Canvas Preview ────────────────────────────────
    _rgb565ToStr(color565) {
        const r = ((color565 >> 11) & 0x1F) * 8;
        const g = ((color565 >> 5) & 0x3F) * 4;
        const b = (color565 & 0x1F) * 8;
        return `rgb(${r},${g},${b})`;
    }

    _resolveColor(tok) {
        tok = (tok || '').trim();
        if (this._tftColors[tok] !== undefined) return this._rgb565ToStr(this._tftColors[tok]);
        if (tok.startsWith('0x') || tok.startsWith('0X')) return this._rgb565ToStr(parseInt(tok, 16));
        if (!isNaN(tok)) return this._rgb565ToStr(parseInt(tok));
        return '#888';
    }

    _parseArgs(str) {
        const args = [];
        let depth = 0, cur = '', inStr = false;
        for (const ch of str) {
            if (ch === '"' || ch === "'") inStr = !inStr;
            if (!inStr && ch === '(') depth++;
            if (!inStr && ch === ')') depth--;
            if (!inStr && ch === ',' && depth === 0) { args.push(cur.trim()); cur = ''; }
            else cur += ch;
        }
        if (cur.trim()) args.push(cur.trim());
        return args;
    }

    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    parseAndRenderCode(code) {
        if (!this.dom.canvas) return;
        const ctx = this.ctx;
        const W = this.dom.canvas.width;
        const H = this.dom.canvas.height;

        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);

        let textColor = '#ffffff';
        let fontSize = 8;

        for (const line of code.split('\n')) {
            const trimmed = line.trim();
            if (trimmed.startsWith('//') || trimmed.startsWith('*')) continue;

            const match = trimmed.match(/tft\.(\w+)(?:<[^>]*>)?\s*\(([^;]*)\)/);
            if (!match) continue;

            const cmd = match[1];
            const args = this._parseArgs(match[2]);

            try {
                switch (cmd) {
                    case 'fillScreen':
                        ctx.fillStyle = this._resolveColor(args[0]);
                        ctx.fillRect(0, 0, W, H);
                        break;
                    case 'fillRect':
                        ctx.fillStyle = this._resolveColor(args[4]);
                        ctx.fillRect(+args[0], +args[1], +args[2], +args[3]);
                        break;
                    case 'drawRect':
                        ctx.strokeStyle = this._resolveColor(args[4]);
                        ctx.lineWidth = 1;
                        ctx.strokeRect(+args[0] + 0.5, +args[1] + 0.5, +args[2], +args[3]);
                        break;
                    case 'fillRoundRect':
                        ctx.fillStyle = this._resolveColor(args[5]);
                        this._roundRect(ctx, +args[0], +args[1], +args[2], +args[3], +args[4]);
                        ctx.fill();
                        break;
                    case 'drawRoundRect':
                        ctx.strokeStyle = this._resolveColor(args[5]);
                        ctx.lineWidth = 1;
                        this._roundRect(ctx, +args[0], +args[1], +args[2], +args[3], +args[4]);
                        ctx.stroke();
                        break;
                    case 'fillCircle':
                        ctx.fillStyle = this._resolveColor(args[3]);
                        ctx.beginPath();
                        ctx.arc(+args[0], +args[1], +args[2], 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'drawCircle':
                        ctx.strokeStyle = this._resolveColor(args[3]);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(+args[0], +args[1], +args[2], 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'fillTriangle': {
                        ctx.fillStyle = this._resolveColor(args[6]);
                        ctx.beginPath();
                        ctx.moveTo(+args[0], +args[1]);
                        ctx.lineTo(+args[2], +args[3]);
                        ctx.lineTo(+args[4], +args[5]);
                        ctx.closePath(); ctx.fill();
                        break;
                    }
                    case 'drawLine':
                        ctx.strokeStyle = this._resolveColor(args[4]);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(+args[0], +args[1]);
                        ctx.lineTo(+args[2], +args[3]);
                        ctx.stroke();
                        break;
                    case 'drawPixel':
                        ctx.fillStyle = this._resolveColor(args[2]);
                        ctx.fillRect(+args[0], +args[1], 1, 1);
                        break;
                    case 'setTextColor':
                        textColor = this._resolveColor(args[0]);
                        break;
                    case 'setTextSize':
                        fontSize = Math.max(6, (+args[0] || 1) * 8);
                        break;
                    case 'drawString':
                    case 'drawCentreString':
                    case 'setCursor':
                        break; // handled by print/println
                    case 'print':
                    case 'println': {
                        const txt = args[0]?.replace(/^["']|["']$/g, '') || '';
                        ctx.fillStyle = textColor;
                        ctx.font = `${fontSize}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.fillText(txt, 0, fontSize);
                        break;
                    }
                    case 'pushImage': {
                        // Draw the imported design background if available
                        if (this._bgImage && this._bgImage.complete) {
                            ctx.drawImage(this._bgImage, +args[0], +args[1], +args[2] || W, +args[3] || H);
                        } else {
                            // Placeholder while image not loaded
                            ctx.strokeStyle = '#38bdf8';
                            ctx.setLineDash([4, 4]);
                            ctx.strokeRect(+args[0] + 0.5, +args[1] + 0.5, +args[2] || W, +args[3] || H);
                            ctx.setLineDash([]);
                            ctx.fillStyle = 'rgba(56,189,248,0.08)';
                            ctx.fillRect(+args[0], +args[1], +args[2] || W, +args[3] || H);
                            ctx.fillStyle = '#38bdf8';
                            ctx.font = '10px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(`[ ${args[4] || 'image'} ]`, (+args[0] + (+args[2] || W) / 2), (+args[1] + (+args[3] || H) / 2));
                            ctx.textAlign = 'left';
                        }
                        break;
                    }
                }
            } catch (err) { /* skip malformed commands */ }
        }
    }

    // ─── Inspector / Properties Panel ─────────────────────────────────────────
    renderInspector(model) {
        if (!this.dom.interactionPanel) return;

        const screen = model.activeScreen;
        const el = screen ? screen.elements.find(e => e.id === model.selectedElementId) : null;

        if (!el) {
            this.dom.interactionPanel.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;
                            color: var(--text-muted); gap: 10px; opacity: 0.5; padding: 20px;">
                    <i data-lucide="mouse-pointer-2" style="width: 32px; height: 32px;"></i>
                    <span style="font-size: 0.7rem;">Selecione um elemento</span>
                </div>
            `;
            if (window.lucide) window.lucide.createIcons();
            return;
        }

        this.dom.interactionPanel.innerHTML = `
            <div class="inspector-group">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">PROPRIEDADES</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div class="input-field compact">
                        <span>Nome</span>
                        <input type="text" data-prop="name" value="${el.name || ''}">
                    </div>
                    <div class="input-field compact">
                        <span>Cor</span>
                        <input type="color" data-prop="color" value="${el.color || '#38bdf8'}">
                    </div>
                </div>
            </div>

            <div class="inspector-group" style="margin-top:12px;">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">POSIÇÃO & TAMANHO</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div class="input-field compact"><span>X</span><input type="number" data-prop="x" value="${el.x ?? 10}"></div>
                    <div class="input-field compact"><span>Y</span><input type="number" data-prop="y" value="${el.y ?? 10}"></div>
                    <div class="input-field compact"><span>W</span><input type="number" data-prop="w" value="${el.w ?? 50}"></div>
                    <div class="input-field compact"><span>H</span><input type="number" data-prop="h" value="${el.h ?? 50}"></div>
                </div>
            </div>

            <div class="inspector-group" style="margin-top:12px;">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">INTERAÇÃO</div>
                <div class="input-field compact">
                    <span>Ir para Tela</span>
                    <select data-prop="targetScreenId" style="width:100%;">
                        <option value="">Nenhuma</option>
                        ${model.screens.map(s => `<option value="${s.id}" ${el.targetScreenId === s.id ? 'selected' : ''}>${s.name}</option>`).join('')}
                    </select>
                </div>
            </div>

            <button class="secondary-btn del-el-btn" style="width:100%;margin-top:12px;color:#ef4444;border-color:rgba(239,68,68,0.2);">
                <i data-lucide="trash-2" style="width:14px;"></i> Excluir
            </button>
        `;

        this.dom.interactionPanel.querySelectorAll('input, select').forEach(input => {
            const fire = (e) => {
                const prop = e.target.dataset.prop;
                let val = e.target.value;
                if (e.target.type === 'number') val = parseInt(val) || 0;
                // Optimistic: update local element + redraw immediately
                el[prop] = val;
                if (!this._codeEditedManually) this._drawToCanvas(model.activeScreen, this.dom.canvas, model.assets);
                // Persist to backend
                this.onPropertyChange?.(el.id, prop, val);
            };
            input.oninput = fire;
            if (input.tagName === 'SELECT') input.onchange = fire;
        });

        const delBtn = this.dom.interactionPanel.querySelector('.del-el-btn');
        if (delBtn) delBtn.onclick = () => this.onElementDelete?.(el.id);

        if (window.lucide) window.lucide.createIcons();
    }
}
