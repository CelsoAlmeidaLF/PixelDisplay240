/**
 * Prototype Controller - Orchestrates Model, View, and C# Backend
 */
class PrototypeController {
    constructor(model, view) {
        this.model = model;
        this.view = view;
        this.app = null; // Will be set by script.js

        this.draggingElement = null;
        this.dragOffset = { x: 0, y: 0 };

        this.setupViewCallbacks();
    }

    // Called after app is set
    async init(app) {
        this.app = app;
        // Give the view access to the api so Stage features work
        if (app.api) this.view.setApiClient(app.api);
        await this.sync();
    }

    async sync() {
        if (!this.app || !this.app.api) return;
        try {
            const resp = await this.app.api.request('/api/prototype');
            const data = await resp.json();
            this.model.updateFromData(data);
            this.view.render(this.model);
        } catch (err) {
            console.error('Sync failed:', err);
        }
    }

    async callApi(path, method = 'POST', body = null) {
        if (!this.app || !this.app.api) return;
        try {
            const options = {
                method,
                headers: { 'Content-Type': 'application/json' }
            };
            if (body) options.body = JSON.stringify(body);

            const resp = await this.app.api.request(`/api/prototype${path}`, options);
            const data = await resp.json();
            this.model.updateFromData(data);
            this.view.render(this.model);
            return data;
        } catch (err) {
            console.error(`API Call failed (${path}):`, err);
        }
    }

    setupViewCallbacks() {
        this.view.onAddScreen = () => this.callApi('/screen');
        this.view.onSelectScreen = (id) => this.callApi('/screen/select', 'POST', { id });
        this.view.onDeleteScreen = (id) => this.callApi(`/screen/${id}`, 'DELETE');

        this.view.onAddElement = (type, asset = null) => this.callApi('/element', 'POST', {
            screenId: this.model.activeScreenId,
            type,
            asset
        });

        this.view.onSelectElement = (id) => this.callApi('/element/select', 'POST', { id });
        this.view.onElementDelete = (id) => this.callApi(`/element/${this.model.activeScreenId}/${id}`, 'DELETE');

        this.view.onPropertyChange = (elId, prop, val) => {
            if (prop === 'background') {
                this.callApi('/screen/background', 'POST', {
                    screenId: this.model.activeScreenId,
                    assetName: val,
                    dataUrl: this.model.assets.find(a => a.name === val)?.dataUrl
                });
            } else {
                this.callApi('/element/update', 'POST', {
                    screenId: this.model.activeScreenId,
                    elId,
                    updates: { [prop]: val }
                });
            }
        };

        this.view.onAssetUpload = (asset) => this.callApi('/asset', 'POST', asset);
        this.view.onDeleteAsset = (name) => this.callApi(`/asset/${name}`, 'DELETE');

        // Import background from Designer or from disk/Stage
        this.view.onImportBackground = async (dataUrl, sourceName) => {
            const activeId = this.model.activeScreenId;
            if (!activeId) return;
            await this.callApi('/screen/background', 'POST', {
                screenId: activeId,
                assetName: null,
                dataUrl: dataUrl
            });
            // Auto-save rendered code to Stage
            const code = this.view.dom.codePreview?.value || '';
            if (code && this.view.stage) {
                await this.view.stage.saveCppFile(
                    (this.model.activeScreen?.name || 'screen').replace(/\s+/g, '_'),
                    code
                );
                await this.view._loadStageList();
            }
        };

        this.view.onCanvasMouseDown = (e) => this.handleMouseDown(e);
        this.view.onCanvasMouseMove = (e) => this.handleMouseMove(e);
        this.view.onCanvasMouseUp = (e) => this.handleMouseUp(e);

        // Code editor → model sync (fires 800ms after user stops typing)
        this.view.onCodeChanged = (code) => this._syncCodeToModel(code);
    }

    /**
     * Bidirectional sync: parse C++ code → update model elements.
     * Matched by type+order. Creates new, patches existing, deletes removed.
     */
    async _syncCodeToModel(code) {
        const screen = this.model.activeScreen;
        if (!screen) return;

        const fnName = (screen.name || 'Screen')
            .replace(/\s+/g, '_')
            .replace(/[^a-zA-Z0-9_]/g, '');

        const parsed = this.view._parseElementsFromCode(code, fnName);

        // Split current non-asset elements by type for matching
        const rects = screen.elements.filter(e => !e.asset && e.type !== 'circle');
        const circles = screen.elements.filter(e => !e.asset && e.type === 'circle');

        const parsedRects = parsed.filter(p => p.type === 'rect');
        const parsedCircles = parsed.filter(p => p.type === 'circle');

        // Patch / create rects
        for (let i = 0; i < parsedRects.length; i++) {
            const p = parsedRects[i];
            if (i < rects.length) {
                // Patch existing
                await this.callApi('/element/update', 'POST', {
                    screenId: this.model.activeScreenId,
                    elId: rects[i].id,
                    updates: { x: p.x, y: p.y, w: p.w, h: p.h, color: p.color }
                });
            } else {
                // Create new then patch (get ID from model after create)
                await this.callApi('/element', 'POST', {
                    screenId: this.model.activeScreenId,
                    type: 'rect'
                });
                // Newest element is last in active screen
                const newEl = this.model.activeScreen?.elements.slice(-1)[0];
                if (newEl) {
                    await this.callApi('/element/update', 'POST', {
                        screenId: this.model.activeScreenId,
                        elId: newEl.id,
                        updates: { x: p.x, y: p.y, w: p.w, h: p.h, color: p.color }
                    });
                }
            }
        }
        // Delete extra rects
        for (let i = parsedRects.length; i < rects.length; i++) {
            await this.callApi(`/element/${this.model.activeScreenId}/${rects[i].id}`, 'DELETE');
        }

        // Patch / create circles
        for (let i = 0; i < parsedCircles.length; i++) {
            const p = parsedCircles[i];
            if (i < circles.length) {
                await this.callApi('/element/update', 'POST', {
                    screenId: this.model.activeScreenId,
                    elId: circles[i].id,
                    updates: { x: p.x, y: p.y, w: p.w, h: p.h, color: p.color }
                });
            } else {
                await this.callApi('/element', 'POST', {
                    screenId: this.model.activeScreenId,
                    type: 'circle'
                });
                const newEl = this.model.activeScreen?.elements.slice(-1)[0];
                if (newEl) {
                    await this.callApi('/element/update', 'POST', {
                        screenId: this.model.activeScreenId,
                        elId: newEl.id,
                        updates: { x: p.x, y: p.y, w: p.w, h: p.h, color: p.color }
                    });
                }
            }
        }
        // Delete extra circles
        for (let i = parsedCircles.length; i < circles.length; i++) {
            await this.callApi(`/element/${this.model.activeScreenId}/${circles[i].id}`, 'DELETE');
        }
    }

    handleMouseDown(e) {
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const screen = this.model.activeScreen;
        if (!screen) return;

        this.draggingElement = null;

        // Find element under mouse
        for (let i = screen.elements.length - 1; i >= 0; i--) {
            const el = screen.elements[i];
            if (x >= el.x && x <= el.x + el.w && y >= el.y && y <= el.y + el.h) {
                this.draggingElement = el;
                this.dragOffset = { x: x - el.x, y: y - el.y };
                this.view.onSelectElement(el.id);
                break;
            }
        }

        if (!this.draggingElement) {
            this.view.onSelectElement(null);
        }
    }

    handleMouseMove(e) {
        if (!this.draggingElement) return;

        const rect = e.target.getBoundingClientRect();
        const x = Math.round(e.clientX - rect.left - this.dragOffset.x);
        const y = Math.round(e.clientY - rect.top - this.dragOffset.y);

        this.draggingElement.x = x;
        this.draggingElement.y = y;
        this.view.render(this.model);
    }

    async handleMouseUp(e) {
        if (this.draggingElement) {
            await this.callApi('/element/move', 'POST', {
                screenId: this.model.activeScreenId,
                elId: this.draggingElement.id,
                x: this.draggingElement.x,
                y: this.draggingElement.y
            });
            this.draggingElement = null;
        }
    }

    async importFromCollection(dataUrl) {
        return this.callApi('/asset', 'POST', {
            name: `Design_${Date.now()}`,
            dataUrl: dataUrl,
            kind: 'image'
        });
    }

    refresh() { this.sync(); }
}
