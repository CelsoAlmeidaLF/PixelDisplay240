using System.Text.Json;
using Microsoft.Extensions.FileProviders;

var builder = WebApplication.CreateBuilder(new WebApplicationOptions
{
    Args = args,
    ContentRootPath = Directory.GetCurrentDirectory(),
    WebRootPath = "wwwroot"
});

var app = builder.Build();

var contentRoot = app.Environment.ContentRootPath;
var staticProvider = new PhysicalFileProvider(contentRoot);

app.UseDefaultFiles(new DefaultFilesOptions
{
    FileProvider = staticProvider,
    DefaultFileNames = new List<string> { "index.html" }
});

app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = staticProvider
});

var agentConfigPath = Path.Combine(contentRoot, "agent_keys.json");
var jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
var httpClient = new HttpClient();

app.MapGet("/api/agents", () =>
{
    if (!File.Exists(agentConfigPath))
    {
        return Results.Json(new AgentConfig(), jsonOptions);
    }

    var json = File.ReadAllText(agentConfigPath);
    var data = JsonSerializer.Deserialize<AgentConfig>(json, jsonOptions) ?? new AgentConfig();
    return Results.Json(data, jsonOptions);
});

app.MapPost("/api/agents", async (HttpRequest request) =>
{
    var data = await request.ReadFromJsonAsync<AgentConfig>(jsonOptions);
    if (data == null)
    {
        return Results.BadRequest(new { message = "Invalid payload" });
    }

    data.Gemini.ApiKey = (data.Gemini.ApiKey ?? string.Empty).Trim();

    var json = JsonSerializer.Serialize(data, jsonOptions);
    File.WriteAllText(agentConfigPath, json);
    return Results.Ok(new { ok = true });
});

app.MapGet("/api/ai/image", async (string prompt, int width, int height, int? seed) =>
{
    if (string.IsNullOrWhiteSpace(prompt))
    {
        return Results.BadRequest(new { message = "Prompt required" });
    }

    var config = AgentHelpers.LoadAgentConfig(agentConfigPath, jsonOptions);
    var apiKey = config.Gemini.ApiKey?.Trim() ?? string.Empty;
    if (string.IsNullOrWhiteSpace(apiKey))
    {
        return Results.BadRequest(new { message = "Gemini API key not configured" });
    }

    var pixelPrompt = $"pixel art, 1:1 square, low resolution, limited color palette, crisp edges, no gradients, {prompt}";
    var requestBody = new
    {
        contents = new[]
        {
            new
            {
                parts = new[]
                {
                    new { text = pixelPrompt }
                }
            }
        }
    };

    var url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent";

    using var request = new HttpRequestMessage(HttpMethod.Post, url)
    {
        Content = JsonContent.Create(requestBody, options: jsonOptions)
    };
    request.Headers.Add("x-goog-api-key", apiKey);

    using var response = await httpClient.SendAsync(request);
    if (!response.IsSuccessStatusCode)
    {
        var errorBody = await response.Content.ReadAsStringAsync();
        Console.WriteLine($"[AI] Gemini error {response.StatusCode}: {errorBody}");
        return Results.Json(new
        {
            message = "Gemini error",
            status = (int)response.StatusCode,
            body = errorBody
        }, statusCode: StatusCodes.Status502BadGateway);
    }

    var responseText = await response.Content.ReadAsStringAsync();
    try
    {
        using var doc = JsonDocument.Parse(responseText);
        if (!AgentHelpers.TryExtractImageBytes(doc.RootElement, out var bytes))
        {
            Console.WriteLine("[AI] No image bytes found in response:");
            Console.WriteLine(responseText);
            return Results.Json(new
            {
                message = "No image bytes found",
                body = responseText
            }, statusCode: StatusCodes.Status502BadGateway);
        }

        return Results.File(bytes, "image/png");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[AI] Failed to parse response: {ex.Message}");
        Console.WriteLine(responseText);
        return Results.StatusCode(StatusCodes.Status502BadGateway);
    }
});

app.Run();

public sealed class AgentConfig
{
    public GeminiConfig Gemini { get; set; } = new();
}

public sealed class GeminiConfig
{
    public string ApiKey { get; set; } = string.Empty;
}

static class AgentHelpers
{
    public static AgentConfig LoadAgentConfig(string path, JsonSerializerOptions options)
    {
        if (!File.Exists(path))
        {
            return new AgentConfig();
        }

        var json = File.ReadAllText(path);
        return JsonSerializer.Deserialize<AgentConfig>(json, options) ?? new AgentConfig();
    }

    public static bool TryExtractImageBytes(JsonElement root, out byte[] bytes)
    {
        bytes = Array.Empty<byte>();

        if (root.TryGetProperty("candidates", out var candidates) &&
            candidates.ValueKind == JsonValueKind.Array &&
            candidates.GetArrayLength() > 0)
        {
            var first = candidates[0];
            if (TryReadBase64(first, out bytes))
            {
                return true;
            }
        }

        if (root.TryGetProperty("predictions", out var predictions) &&
            predictions.ValueKind == JsonValueKind.Array &&
            predictions.GetArrayLength() > 0)
        {
            var first = predictions[0];
            if (TryReadBase64(first, out bytes))
            {
                return true;
            }
        }

        if (root.TryGetProperty("generatedImages", out var generatedImages) &&
            generatedImages.ValueKind == JsonValueKind.Array &&
            generatedImages.GetArrayLength() > 0)
        {
            var first = generatedImages[0];
            if (TryReadBase64(first, out bytes))
            {
                return true;
            }
        }

        if (root.TryGetProperty("images", out var images) &&
            images.ValueKind == JsonValueKind.Array &&
            images.GetArrayLength() > 0)
        {
            var first = images[0];
            if (TryReadBase64(first, out bytes))
            {
                return true;
            }
        }

        return false;
    }

    static bool TryReadBase64(JsonElement element, out byte[] bytes)
    {
        bytes = Array.Empty<byte>();

        if (element.TryGetProperty("content", out var content) &&
            content.TryGetProperty("parts", out var parts) &&
            parts.ValueKind == JsonValueKind.Array)
        {
            foreach (var part in parts.EnumerateArray())
            {
                if (part.TryGetProperty("inlineData", out var inlineData))
                {
                    if (TryReadInlineData(inlineData, out bytes))
                    {
                        return true;
                    }
                }
            }
        }

        if (element.TryGetProperty("bytesBase64Encoded", out var bytesBase64Encoded) &&
            bytesBase64Encoded.ValueKind == JsonValueKind.String)
        {
            return TryDecode(bytesBase64Encoded.GetString(), out bytes);
        }

        if (element.TryGetProperty("image", out var image) &&
            image.TryGetProperty("imageBytes", out var imageBytes) &&
            imageBytes.ValueKind == JsonValueKind.String)
        {
            return TryDecode(imageBytes.GetString(), out bytes);
        }

        if (element.TryGetProperty("imageBytes", out var imageBytesFlat) &&
            imageBytesFlat.ValueKind == JsonValueKind.String)
        {
            return TryDecode(imageBytesFlat.GetString(), out bytes);
        }

        if (element.TryGetProperty("data", out var data) &&
            data.ValueKind == JsonValueKind.String)
        {
            return TryDecode(data.GetString(), out bytes);
        }

        return false;
    }

    static bool TryReadInlineData(JsonElement inlineData, out byte[] bytes)
    {
        bytes = Array.Empty<byte>();

        if (inlineData.TryGetProperty("data", out var data) &&
            data.ValueKind == JsonValueKind.String)
        {
            return TryDecode(data.GetString(), out bytes);
        }

        if (inlineData.TryGetProperty("bytesBase64Encoded", out var bytesBase64Encoded) &&
            bytesBase64Encoded.ValueKind == JsonValueKind.String)
        {
            return TryDecode(bytesBase64Encoded.GetString(), out bytes);
        }

        return false;
    }

    static bool TryDecode(string? base64, out byte[] bytes)
    {
        bytes = Array.Empty<byte>();
        if (string.IsNullOrWhiteSpace(base64)) return false;

        try
        {
            bytes = Convert.FromBase64String(base64);
            return bytes.Length > 0;
        }
        catch
        {
            return false;
        }
    }
}
