/**
 * Prototype View - Handles DOM manipulation, canvas rendering, and TFT code parsing.
 */
class PrototypeView {
    constructor(apiClient) {
        this.api = apiClient;
        this.stage = null; // set via setApiClient()
        this.dom = {
            screenList: document.getElementById('screen-list'),
            mainGallery: document.getElementById('proto-main-container'),
            canvas: document.getElementById('proto-canvas'),
            assetList: document.getElementById('proto-asset-list'),
            codePreview: document.getElementById('proto-code-preview'),
            elementList: document.getElementById('proto-element-list'),
            interactionPanel: document.getElementById('proto-interaction-panel'),
            fileList: document.getElementById('stage-file-list'),
            addScreenBtn: document.getElementById('btn-add-screen')
        };

        if (this.dom.canvas) {
            this.ctx = this.dom.canvas.getContext('2d');
            this.setupCanvasEvents();
        }

        // Wire code editor → live canvas preview + debounced model sync
        if (this.dom.codePreview) {
            this.dom.codePreview.oninput = () => {
                this._codeEditedManually = true;
                this.parseAndRenderCode(this.dom.codePreview.value);
                // Debounce: after 800ms of no typing, sync code back to model
                clearTimeout(this._codeSyncTimer);
                this._codeSyncTimer = setTimeout(() => {
                    this.onCodeChanged?.(this.dom.codePreview.value);
                }, 800);
            };
        }

        this.setupGeneralEvents();
        this.imageCache = new Map();
        this._bgImage = null;
        this._codeEditedManually = false;

        // TFT Named Color constants (RGB565)
        this._tftColors = {
            TFT_BLACK: 0x0000, TFT_NAVY: 0x000F, TFT_DARKGREEN: 0x03E0,
            TFT_DARKCYAN: 0x03EF, TFT_MAROON: 0x7800, TFT_PURPLE: 0x780F,
            TFT_OLIVE: 0x7BE0, TFT_LIGHTGREY: 0xC618, TFT_DARKGREY: 0x7BEF,
            TFT_BLUE: 0x001F, TFT_GREEN: 0x07E0, TFT_CYAN: 0x07FF,
            TFT_RED: 0xF800, TFT_MAGENTA: 0xF81F, TFT_YELLOW: 0xFFE0,
            TFT_WHITE: 0xFFFF, TFT_ORANGE: 0xFDA0, TFT_GREENYELLOW: 0xB7E0,
            TFT_PINK: 0xFE19, TFT_BROWN: 0x9A60, TFT_GOLD: 0xFEA0,
            TFT_SILVER: 0xC618, TFT_SKYBLUE: 0x867D, TFT_VIOLET: 0x915C
        };
    }

    /** Called by PrototypeController after api is ready */
    setApiClient(apiClient) {
        this.stage = new ProtoStageManager(apiClient);
        this._wireStageEvents();
    }

    setupCanvasEvents() {
        this.dom.canvas.onmousedown = (e) => this.onCanvasMouseDown?.(e);
        this.dom.canvas.onmousemove = (e) => this.onCanvasMouseMove?.(e);
        this.dom.canvas.onmouseup = (e) => this.onCanvasMouseUp?.(e);
    }

    setupGeneralEvents() {
        if (this.dom.addScreenBtn) {
            this.dom.addScreenBtn.onclick = () => {
                const select = document.getElementById('screen-template-select');
                const template = select ? select.value : '';
                this.onAddScreen?.(template);
            };
        }

        // JPG / BMP / PNG import → set as background
        const imgBtn = document.getElementById('btn-upload-image');
        const imgInput = document.getElementById('proto-image-upload');
        if (imgBtn && imgInput) imgBtn.onclick = () => imgInput.click();
        if (imgInput) {
            imgInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => this._handleImageImport(file.name, ev.target.result);
                reader.readAsDataURL(file);
                imgInput.value = '';
            };
        }

        // .h C-array import → parse RGB565 → background
        const hBtn = document.getElementById('btn-upload-h');
        const hInput = document.getElementById('proto-h-upload');
        if (hBtn && hInput) hBtn.onclick = () => hInput.click();
        if (hInput) {
            hInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => this._handleHImport(file.name, ev.target.result);
                reader.readAsText(file);
                hInput.value = '';
            };
        }

        // ── TFT Command Builder ────────────────────────────────────────────
        this._cmdBuilder = new TFTCommandBuilder((codeLine) => {
            // Insert at cursor in the textarea, then trigger sync
            const ta = this.dom.codePreview;
            if (!ta) return;

            const pos = ta.selectionEnd;
            const before = ta.value.slice(0, pos);
            const after = ta.value.slice(pos);
            // Insert after the current line
            const lineEnd = before.lastIndexOf('\n') + 1;
            const lineStart = before.lastIndexOf('\n', pos - 1) + 1;
            // Find end of current line
            const currentLineEnd = ta.value.indexOf('\n', pos);
            const insertAt = currentLineEnd === -1 ? ta.value.length : currentLineEnd;

            ta.value = ta.value.slice(0, insertAt) + '\n' + codeLine + ta.value.slice(insertAt);
            // Move cursor after inserted line
            ta.selectionStart = ta.selectionEnd = insertAt + codeLine.length + 1;
            ta.focus();

            // Trigger live preview + debounced model sync
            this._codeEditedManually = true;
            this.parseAndRenderCode(ta.value);
            clearTimeout(this._codeSyncTimer);
            this._codeSyncTimer = setTimeout(() => {
                this.onCodeChanged?.(ta.value);
            }, 800);
        });

        // Wire all TFT command buttons to Add Element instead of Builder
        document.querySelectorAll('.tft-cmd-btn').forEach(btn => {
            btn.onclick = () => {
                const cmdId = btn.dataset.cmd;
                if (cmdId && this.onAddElement) {
                    // For text elements, prompt for content first? Or just add default.
                    // Let's just add default element and let user edit properties.
                    this.onAddElement(cmdId);
                }
            };
        });
    }

    /** Wire Stage-specific events (called after api is ready) */
    _wireStageEvents() {
        // Refresh Stage list
        const btnRefresh = document.getElementById('btn-refresh-stage');
        if (btnRefresh) btnRefresh.onclick = () => this._loadStageList();

        // Save code to Stage
        const btnSaveCode = document.getElementById('btn-save-code-stage');
        if (btnSaveCode) btnSaveCode.onclick = () => {
            const code = this.dom.codePreview?.value || '';
            this.stage.saveCppFile('pixelstream_v5', code).then(ok => {
                const toast = window.app?.toast;
                if (toast) toast.show(ok ? 'success' : 'error', ok ? 'Código salvo no Stage!' : 'Falha ao salvar');
            });
        };

        // Stage file list: clicking a file uses it
        if (this.stage) {
            this.stage.onFileSelect = (f) => this._onStageFileSelected(f);
        }

        // Initial load
        this._loadStageList();
    }

    async _loadStageList() {
        if (!this.stage) return;
        const container = document.getElementById('stage-file-list');
        await this.stage.renderFileList(container);
    }

    /** Handle JPG/BMP/PNG imported from disk → set as screen background + save to Stage */
    async _handleImageImport(filename, dataUrl) {
        // Set as active screen background via callback
        this.onImportBackground?.(dataUrl, filename);

        // Update proto canvas immediately
        const img = new Image();
        img.onload = () => {
            this._bgImage = img;
            const ctx = this.ctx;
            if (ctx) {
                ctx.clearRect(0, 0, 240, 240);
                ctx.drawImage(img, 0, 0, 240, 240);
            }
        };
        img.src = dataUrl;

        // Auto-save to Stage
        if (this.stage) {
            await this.stage.saveImage(filename, dataUrl);
            await this._loadStageList();
            const toast = window.app?.toast;
            if (toast) toast.show('success', 'Imagem importada!', `${filename} salvo no Stage e carregado como fundo.`);
        }
    }

    /** Handle .h C-array → parse RGB565 → render + save to Stage */
    async _handleHImport(filename, content) {
        if (!this.stage) {
            console.warn('[Proto] Stage not ready for .h import');
            return;
        }

        const parsed = this.stage.parseHFile(content);
        if (!parsed) {
            const toast = window.app?.toast;
            if (toast) toast.show('error', 'Erro ao parsear .h', 'Nenhum array uint16_t encontrado.');
            return;
        }

        const dataUrl = this.stage.hArrayToDataUrl(parsed);

        // Show info
        const info = document.getElementById('h-import-info');
        if (info) {
            info.style.display = 'block';
            info.textContent = `${parsed.name} [${parsed.width}×${parsed.height}] — ${parsed.pixels.length} px`;
        }

        // Set as background
        this.onImportBackground?.(dataUrl, parsed.name);

        // Render on canvas
        const img = new Image();
        img.onload = () => {
            this._bgImage = img;
            const ctx = this.ctx;
            if (ctx) { ctx.clearRect(0, 0, 240, 240); ctx.drawImage(img, 0, 0, 240, 240); }
        };
        img.src = dataUrl;

        // Save the original .h AND the rendered PNG to Stage
        await this.stage.saveHFile(filename, content);
        await this.stage.saveImage(parsed.name + '_preview', dataUrl);
        await this._loadStageList();

        const toast = window.app?.toast;
        if (toast) toast.show('success', 'Array .h importado!',
            `${parsed.name} (${parsed.width}×${parsed.height}) carregado. Arquivo salvo no Stage.`);
    }

    /** When user clicks a Stage file — load it into the prototype */
    async _onStageFileSelected(file) {
        const name = file.name;
        const ext = name.split('.').pop().toLowerCase();

        // Fetch the file from the Stage static path
        const url = `/stage/${name}`; // served as static

        if (ext === 'h') {
            const resp = await fetch(url);
            const text = await resp.text();
            await this._handleHImport(name, text);
        } else if (['png', 'jpg', 'jpeg', 'bmp'].includes(ext)) {
            // Convert to dataURL
            const resp = await fetch(url);
            const blob = await resp.blob();
            const reader = new FileReader();
            reader.onload = (ev) => this._handleImageImport(name, ev.target.result);
            reader.readAsDataURL(blob);
        } else if (ext === 'cpp' || ext === 'ino') {
            const resp = await fetch(url);
            const text = await resp.text();
            if (this.dom.codePreview) {
                this.dom.codePreview.value = text;
                this._codeEditedManually = true;
                this.parseAndRenderCode(text);
            }
        }
    }

    render(model) {
        this.renderScreenList(model);
        this.renderMainGallery(model);
        this.renderAssetList(model);
        this.renderWorkspace(model);     // ALWAYS draw model to canvas
        this.renderElementList(model);
        this.renderCodePreview(model);   // ALWAYS regenerate C++ code from model
        this.renderInspector(model);

        const title = document.getElementById('active-screen-title');
        if (title && model.activeScreen) {
            title.textContent = model.activeScreen.name;
        }
    }

    // ─── Screen List ───────────────────────────────────────────────────────────
    renderScreenList(model) {
        if (!this.dom.screenList) return;
        this.dom.screenList.innerHTML = '';

        model.screens.forEach(screen => {
            const isActive = screen.id === model.activeScreenId;
            const item = document.createElement('div');
            item.className = `layer-item ${isActive ? 'active' : ''}`;
            item.onclick = () => {
                this._codeEditedManually = false; // reset on screen switch
                this.onSelectScreen?.(screen.id);
            };
            item.innerHTML = `
                <i data-lucide="monitor" style="width:14px;"></i>
                <span class="screen-name" style="flex:1;">${screen.name}</span>
                <button class="action-btn delete-screen" title="Excluir"><i data-lucide="trash-2"></i></button>
            `;
            const delBtn = item.querySelector('.delete-screen');
            delBtn.onclick = (e) => { e.stopPropagation(); this.onDeleteScreen?.(screen.id); };
            this.dom.screenList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Main Gallery ──────────────────────────────────────────────────────────
    renderMainGallery(model) {
        if (!this.dom.mainGallery) return;
        this.dom.mainGallery.innerHTML = '';

        model.screens.forEach(screen => {
            const isActive = screen.id === model.activeScreenId;
            const card = document.createElement('div');
            card.className = `screen-card ${isActive ? 'active' : ''}`;
            card.onclick = () => this.onSelectScreen?.(screen.id);
            card.style.cssText = `
                display: flex; flex-direction: column; padding: 12px; gap: 8px;
                width: 220px;
                background: ${isActive ? 'rgba(56, 189, 248, 0.1)' : 'var(--card-bg)'};
                border: ${isActive ? '2px solid var(--primary)' : '1px solid var(--border)'};
                border-radius: 12px; cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s; position: relative;
            `;
            const title = document.createElement('div');
            title.style.cssText = 'font-size: 0.65rem; font-weight: 800; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;';
            title.textContent = screen.name;

            const canvas = document.createElement('canvas');
            canvas.width = 240; canvas.height = 240;
            canvas.style.cssText = 'width: 100%; height: auto; background: #000; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';

            card.appendChild(title);
            card.appendChild(canvas);
            this.dom.mainGallery.appendChild(card);
            this._drawToCanvas(screen, canvas, model.assets);
        });
    }

    // ─── Workspace (Active Screen Canvas) ──────────────────────────────────────
    renderWorkspace(model) {
        if (!this.dom.canvas || !model.activeScreen) return;
        // Always draw from model — textarea parser is a separate real-time overlay
        this._drawToCanvas(model.activeScreen, this.dom.canvas, model.assets);
    }

    _drawToCanvas(screen, canvas, assets) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background: either a dataURL (from designer import) or asset name
        if (screen.background) {
            const img = this._getImg(screen.background);
            if (img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                // Keep reference for code parser pushImage
                if (canvas === this.dom.canvas) this._bgImage = img;
            } else {
                img.onload = () => {
                    if (canvas === this.dom.canvas) this._bgImage = img;
                    this._drawToCanvas(screen, canvas, assets);
                };
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (canvas === this.dom.canvas) this._bgImage = null;
        }

        // Elements
        screen.elements.forEach(el => {
            ctx.save();
            const color = el.color || '#38bdf8';

            if (el.asset) {
                const asset = assets.find(a => a.name === el.asset);
                if (asset) {
                    const img = this._getImg(asset.dataUrl);
                    if (img.complete) {
                        ctx.drawImage(img, el.x, el.y, el.w, el.h);
                    } else {
                        img.onload = () => this._drawToCanvas(screen, canvas, assets);
                    }
                } else {
                    // Fallback for missing asset
                    ctx.strokeStyle = '#ef4444';
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(el.x, el.y, el.w, el.h);
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = 'center';
                    ctx.fillText('?', el.x + el.w / 2, el.y + el.h / 2);
                }
            } else {
                // Determine style based on fill vs draw
                const isOutline = el.type.startsWith('draw') && !el.type.includes('String') && el.type !== 'drawPixel';
                if (isOutline) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                } else {
                    ctx.fillStyle = color;
                }

                switch (el.type) {
                    case 'fillCircle':
                    case 'circle': // legacy
                    case 'drawCircle': {
                        const r = Math.min(el.w, el.h) / 2;
                        ctx.beginPath();
                        ctx.arc(el.x + el.w / 2, el.y + el.h / 2, r, 0, Math.PI * 2);
                        isOutline ? ctx.stroke() : ctx.fill();
                        break;
                    }
                    case 'fillRoundRect': {
                        const r = Math.min(el.w, el.h) / 4; // approximate radius
                        this._roundRect(ctx, el.x, el.y, el.w, el.h, r);
                        ctx.fill();
                        break;
                    }
                    case 'fillTriangle': {
                        ctx.beginPath();
                        ctx.moveTo(el.x + el.w / 2, el.y); // Top
                        ctx.lineTo(el.x, el.y + el.h);   // Bottom Left
                        ctx.lineTo(el.x + el.w, el.y + el.h); // Bottom Right
                        ctx.closePath();
                        ctx.fill();
                        break;
                    }
                    case 'fillEllipse': {
                        ctx.beginPath();
                        ctx.ellipse(el.x + el.w / 2, el.y + el.h / 2, el.w / 2, el.h / 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }
                    case 'drawLine': {
                        ctx.beginPath();
                        ctx.moveTo(el.x, el.y);
                        ctx.lineTo(el.x + el.w, el.y + el.h);
                        ctx.stroke();
                        break;
                    }
                    case 'drawFastHLine': {
                        ctx.beginPath();
                        ctx.moveTo(el.x, el.y);
                        ctx.lineTo(el.x + el.w, el.y);
                        ctx.stroke();
                        break;
                    }
                    case 'drawFastVLine': {
                        ctx.beginPath();
                        ctx.moveTo(el.x, el.y);
                        ctx.lineTo(el.x, el.y + el.h);
                        ctx.stroke();
                        break;
                    }
                    case 'drawPixel': {
                        ctx.fillRect(el.x, el.y, 2, 2); // visible size
                        break;
                    }
                    case 'drawString':
                    case 'drawCentreString': {
                        const fontSize = Math.max(10, el.h);
                        ctx.font = `${fontSize}px monospace`;
                        ctx.textBaseline = 'top';
                        // Use element Name as text content hack
                        const text = (el.name.startsWith(el.type) ? 'Text' : el.name) || 'Text';

                        if (el.type === 'drawCentreString') {
                            ctx.textAlign = 'center';
                            ctx.fillText(text, el.x + el.w / 2, el.y);
                        } else {
                            ctx.textAlign = 'left';
                            ctx.fillText(text, el.x, el.y);
                        }
                        break;
                    }
                    case 'drawRect': {
                        ctx.strokeRect(el.x, el.y, el.w, el.h);
                        ctx.strokeRect(el.x, el.y, el.w, el.h);
                        break;
                    }
                    case 'fillRect':
                    default: {
                        ctx.fillRect(el.x, el.y, el.w, el.h);
                        break;
                    }
                }
            }
            ctx.restore();
        });
    }

    _getImg(dataUrl) {
        if (this.imageCache.has(dataUrl)) return this.imageCache.get(dataUrl);
        const img = new Image();
        img.src = dataUrl;
        this.imageCache.set(dataUrl, img);
        return img;
    }

    // ─── Asset List ────────────────────────────────────────────────────────────
    renderAssetList(model) {
        if (!this.dom.assetList) return;
        this.dom.assetList.innerHTML = '';

        if (model.assets.length === 0) {
            this.dom.assetList.innerHTML = '<div class="hint" style="grid-column: 1/-1;">Sem assets</div>';
            return;
        }

        model.assets.forEach(asset => {
            const item = document.createElement('div');
            item.className = 'asset-item';
            item.style.cssText = 'background: var(--bg-dark); border: 1px solid var(--border); border-radius: 8px; padding: 6px; display: flex; flex-direction: column; gap: 4px;';
            item.innerHTML = `
                <img src="${asset.dataUrl}" style="width: 100%; height: 40px; object-fit: contain; background: #000; border-radius: 4px;">
                <div style="font-size: 0.6rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: center;">${asset.name}</div>
                <div style="display: flex; gap: 2px;">
                    <button class="small-btn bg-btn" title="Fundo"><i data-lucide="monitor" style="width:10px;"></i></button>
                    <button class="small-btn add-btn" title="Add"><i data-lucide="plus" style="width:10px;"></i></button>
                    <button class="small-btn del-btn" title="Apagar"><i data-lucide="trash-2" style="width:10px;"></i></button>
                </div>
            `;
            item.querySelector('.bg-btn').onclick = (e) => { e.stopPropagation(); this.onPropertyChange?.(null, 'background', asset.name); };
            item.querySelector('.add-btn').onclick = (e) => { e.stopPropagation(); this.onAddElement?.('image', asset.name); };
            item.querySelector('.del-btn').onclick = (e) => { e.stopPropagation(); this.onDeleteAsset?.(asset.name); };
            this.dom.assetList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Element List ──────────────────────────────────────────────────────────
    renderElementList(model) {
        if (!this.dom.elementList || !model.activeScreen) return;
        this.dom.elementList.innerHTML = '';

        model.activeScreen.elements.forEach(el => {
            const isActive = el.id === model.selectedElementId;
            const item = document.createElement('div');
            item.className = `layer-item ${isActive ? 'active' : ''}`;
            item.onclick = () => this.onSelectElement?.(el.id);
            item.innerHTML = `
                <i data-lucide="${el.asset ? 'image' : 'square'}" style="width:12px;"></i>
                <span style="flex:1;">${el.name}</span>
                <button class="action-btn del-el" title="Remover"><i data-lucide="trash-2" style="width:12px;"></i></button>
            `;
            item.querySelector('.del-el').onclick = (e) => { e.stopPropagation(); this.onElementDelete?.(el.id); };
            this.dom.elementList.appendChild(item);
        });

        if (window.lucide) window.lucide.createIcons();
    }

    // ─── Code Preview (Auto-generated + Editable) ─────────────────────────────
    renderCodePreview(model) {
        if (!this.dom.codePreview) return;

        // If user is actively typing, don't overwrite!
        // (This flag is usually managed by focus/blur, but let's be safe)
        if (document.activeElement === this.dom.codePreview) return;

        // Capture existing custom code from current value before regenerating
        const currentCode = this.dom.codePreview.value;
        const customCodeMap = new Map();
        
        // Regex to find user custom blocks: // USER_CODE_BEGIN {ScreenName} ... // USER_CODE_END
        // Or simpler: just match content between well-known markers if we supported them.
        
        // BETTER STRATEGY: 
        // We can't easily merge custom logic with auto-generated UI code without a complex AST.
        // INSTEAD, we will generate the code normally, but if the user has written CUSTOM functions
        // outside the draw functions, we preserve them.
        
        // 1. Preserve headers/globals (everything before first draw_ function)
        const globalsMatch = currentCode.match(/^([\s\S]*?)(?=void\s+draw_)/);
        const preservedGlobals = globalsMatch ? globalsMatch[1] : 
            '// PixelStream v5 - Auto-generated Code\n' +
            '// Edit freely — changes reflect in the display preview in real time.\n' +
            '#include <TFT_eSPI.h>\n' +
            '#include <SPI.h>\n' +
            'extern TFT_eSPI tft;\n\n';

        let code = preservedGlobals;

        // 2. Generate Draw Functions
        model.screens.forEach(screen => {
            const fnName = screen.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')

            // Try to extract existing custom code inside this function from previous code?
            // This is hard to do reliably without markers. 
            // For now, we unfortunately have to overwrite the draw_ function body to ensure WYSIWYG sync.
            // BUT, we can append a comment encouraging separate logic functions.
            
            // Generate Asset background comments
            if (screen.background && screen.background.startsWith('data:')) {
                const arrName = `${fnName}_bg`;
                if (!code.includes(`uint16_t ${arrName}`)) { // unique check
                    code += `// NOTE: Export "${fnName}" from the Designer as a C array named "${arrName}"\n`;
                    code += `// extern const uint16_t ${arrName}[] PROGMEM;\n\n`;
                }
            }

            code += `void draw_${fnName}() {\n`;

            if (screen.background && screen.background.startsWith('data:')) {
                // If the screen HAS a background image (dataURL), we draw only ONE pushImage call for it.
                // The current bug is likely that we are adding this line repeatedly or confusing it with an "asset" based pushImage.
                code += `  tft.pushImage(0, 0, 240, 240, ${fnName}_bg);\n`;
            } else if (screen.backgroundAsset) {
                code += `  tft.pushImage(0, 0, 240, 240, ${screen.backgroundAsset});\n`;
            } else {
                code += `  tft.fillScreen(TFT_BLACK);\n`;
            }

            screen.elements.forEach(el => {
                const color = this.hexTo565(el.color);
                const nameComment = `// ${el.name}`;

                if (el.asset) {
                    code += `  tft.pushImage(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${el.asset}); ${nameComment}\n`;
                } else {
                    switch (el.type) {
                        case 'fillCircle':
                        case 'circle': // legacy
                        case 'drawCircle': {
                            const cx = Math.round(el.x + el.w / 2);
                            const cy = Math.round(el.y + el.h / 2);
                            const r = Math.round(Math.min(el.w, el.h) / 2);
                            const cmd = el.type.startsWith('draw') ? 'drawCircle' : 'fillCircle';
                            code += `  tft.${cmd}(${cx}, ${cy}, ${r}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'fillRoundRect':
                        case 'drawRoundRect': {
                            const r = Math.round(Math.min(el.w, el.h) / 4);
                            const cmd = el.type.startsWith('draw') ? 'drawRoundRect' : 'fillRoundRect';
                            code += `  tft.${cmd}(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${r}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'fillTriangle':
                        case 'drawTriangle': {
                            // Isosceles triangle inside bounding box
                            const x0 = Math.round(el.x + el.w / 2), y0 = el.y;
                            const x1 = el.x, y1 = el.y + el.h;
                            const x2 = el.x + el.w, y2 = el.y + el.h;
                            const cmd = el.type.startsWith('draw') ? 'drawTriangle' : 'fillTriangle';
                            code += `  tft.${cmd}(${x0}, ${y0}, ${x1}, ${y1}, ${x2}, ${y2}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'fillEllipse':
                        case 'drawEllipse': {
                            const cx = Math.round(el.x + el.w / 2);
                            const cy = Math.round(el.y + el.h / 2);
                            const rx = Math.round(el.w / 2);
                            const ry = Math.round(el.h / 2);
                            const cmd = el.type.startsWith('draw') ? 'drawEllipse' : 'fillEllipse';
                            code += `  tft.${cmd}(${cx}, ${cy}, ${rx}, ${ry}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'drawLine': {
                            const x1 = el.x + el.w;
                            const y1 = el.y + el.h;
                            code += `  tft.drawLine(${el.x}, ${el.y}, ${x1}, ${y1}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'drawFastHLine': {
                            code += `  tft.drawFastHLine(${el.x}, ${el.y}, ${el.w}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'drawFastVLine': {
                            code += `  tft.drawFastVLine(${el.x}, ${el.y}, ${el.h}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'drawPixel': {
                            code += `  tft.drawPixel(${el.x}, ${el.y}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'drawString':
                        case 'drawCentreString': {
                            // Use Name as text content
                            const text = el.name.replace(/"/g, '\\"'); // escape quotes
                            // Size heuristic: assume height 8px = size 1
                            const size = Math.max(1, Math.round(el.h / 8));
                            code += `  tft.setTextColor(${color}); tft.setTextSize(${size});\n`;
                            if (el.type === 'drawCentreString') {
                                const cx = Math.round(el.x + el.w / 2);
                                code += `  tft.drawCentreString("${text}", ${cx}, ${el.y}, 2); ${nameComment}\n`;
                            } else {
                                code += `  tft.drawString("${text}", ${el.x}, ${el.y}); ${nameComment}\n`;
                            }
                            break;
                        }
                        case 'drawRect': {
                            code += `  tft.drawRect(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${color}); ${nameComment}\n`;
                            break;
                        }
                        case 'fillRect':
                        default: {
                            code += `  tft.fillRect(${el.x}, ${el.y}, ${el.w}, ${el.h}, ${color}); ${nameComment}\n`;
                            break;
                        }
                    }
                }
            });

            code += '}\n\n';
        });
        
        // 3. Preserve User Logic (anything after the generated functions)
        // Find where the last generated function ended in the OLD code vs NEW code isn't 1:1.
        // Simple heuristic: If the user appended logic at the end, keep it.
        // We look for "void loop" or "void setup" or other functions in the old code that are NOT draw_ functions
        
        // Extract all functions from old code
        const customFuncs = [];
        const funcRegex = /void\s+(?!draw_)([a-zA-Z0-9_]+)\s*\([^)]*\)\s*\{[\s\S]*?\}/g;
        let match;
        while ((match = funcRegex.exec(currentCode)) !== null) {
            customFuncs.push(match[0]);
        }
        
        if (customFuncs.length > 0) {
            code += '// --- User Logic Preserved ---\n';
            code += customFuncs.join('\n\n');
            code += '\n';
        }

        // Only update if changed (prevents cursor jumping if exact same)
        if (this.dom.codePreview.value !== code) {
            this.dom.codePreview.value = code;
        }
    }

    hexTo565(hex) {
        if (!hex) return '0x0000';
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const rgb565 = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
        return '0x' + rgb565.toString(16).toUpperCase().padStart(4, '0');
    }

    /** Convert RGB565 integer back to hex color string */
    _rgb565ToHex(c) {
        const r = Math.round(((c >> 11) & 0x1F) * 255 / 31);
        const g = Math.round(((c >> 5) & 0x3F) * 255 / 63);
        const b = Math.round((c & 0x1F) * 255 / 31);
        return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
    }

    /**
     * Parse the active screen's function from C++ code and extract elements.
     * Returns [{type, x, y, w, h, color, name}]
     */
    _parseElementsFromCode(code, fnName) {
        const elements = [];
        // Extract just the body of the active screen function
        const fnRe = new RegExp(`void\\s+draw_${fnName}\\s*\\([^)]*\\)\\s*\\{([\\s\\S]*?)\\}`);
        const fnMatch = code.match(fnRe);
        const body = fnMatch ? fnMatch[1] : code;

        const lines = body.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('//') && !trimmed.includes('//')) continue; 
            
            // Extract comment as name if present:  code... // name
            let name = null;
            const commentMatch = trimmed.match(/\/\/\s*(.*)$/);
            if (commentMatch) name = commentMatch[1].trim();

            // Helper to parse color
            const parseColor = (val) => this._rgb565ToHex(parseInt(val, val.startsWith('0x') || val.startsWith('0X') ? 16 : 10));

            // 1. Rects (fill/draw)
            // tft.fillRect(x, y, w, h, color)
            const rectM = trimmed.match(/tft\.(fill|draw)Rect\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (rectM) {
                elements.push({
                    type: rectM[1] + 'Rect',
                    x: parseInt(rectM[2]), y: parseInt(rectM[3]),
                    w: parseInt(rectM[4]), h: parseInt(rectM[5]),
                    color: parseColor(rectM[6]),
                    name: name || (rectM[1] + 'Rect')
                });
                continue;
            }

            // 2. Circles (fill/draw)
            // tft.fillCircle(cx, cy, r, color) -> convert to box x,y,w,h
            const circM = trimmed.match(/tft\.(fill|draw)Circle\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (circM) {
                const cx = parseInt(circM[2]), cy = parseInt(circM[3]), r = parseInt(circM[4]);
                elements.push({
                    type: circM[1] + 'Circle',
                    x: cx - r, y: cy - r, w: r * 2, h: r * 2,
                    color: parseColor(circM[5]),
                    name: name || (circM[1] + 'Circle')
                });
                continue;
            }

            // 3. Round Rects
            // tft.fillRoundRect(x, y, w, h, r, color)
            const rRectM = trimmed.match(/tft\.(fill|draw)RoundRect\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (rRectM) {
                elements.push({
                    type: rRectM[1] + 'RoundRect',
                    x: parseInt(rRectM[2]), y: parseInt(rRectM[3]),
                    w: parseInt(rRectM[4]), h: parseInt(rRectM[5]),
                    color: parseColor(rRectM[7]),
                    name: name || (rRectM[1] + 'RoundRect')
                });
                continue;
            }

            // 4. Lines
            // tft.drawLine(x0, y0, x1, y1, color) -> box x,y,w,h
            const lineM = trimmed.match(/tft\.drawLine\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (lineM) {
                const x0 = parseInt(lineM[1]), y0 = parseInt(lineM[2]);
                const x1 = parseInt(lineM[3]), y1 = parseInt(lineM[4]);
                elements.push({
                    type: 'drawLine',
                    x: x0, y: y0, w: x1 - x0, h: y1 - y0, // Storing delta as w/h for lines
                    color: parseColor(lineM[5]),
                    name: name || 'line'
                });
                continue;
            }

            // 5. Fast Lines (H/V)
            const hLineM = trimmed.match(/tft\.drawFastHLine\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (hLineM) {
                elements.push({
                    type: 'drawFastHLine',
                    x: parseInt(hLineM[1]), y: parseInt(hLineM[2]),
                    w: parseInt(hLineM[3]), h: 2,
                    color: parseColor(hLineM[4]),
                    name: name || 'hLine'
                });
                continue;
            }
            const vLineM = trimmed.match(/tft\.drawFastVLine\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(0[xX][0-9A-Fa-f]+|\d+)/);
            if (vLineM) {
                elements.push({
                    type: 'drawFastVLine',
                    x: parseInt(vLineM[1]), y: parseInt(vLineM[2]),
                    w: 2, h: parseInt(vLineM[3]),
                    color: parseColor(vLineM[4]),
                    name: name || 'vLine'
                });
                continue;
            }

            // 6. Text (drawString / drawCentreString)
            // tft.drawString("text", x, y)
            // Note: color is stateful (setTextColor), so this is tricky. 
            // We'll rely on the visual editor's property panel which keeps color in element logic.
            // But here we need to extract position.
            const txtM = trimmed.match(/tft\.(drawString|drawCentreString)\s*\(\s*"(.*?)"\s*,\s*(-?\d+)\s*,\s*(-?\d+)/);
            if (txtM) {
                // We miss color here because it's on a previous line. 
                // A full AST parser is needed for state, but we can try to find previous setTextColor
                // For now, default white if not found or keep existing.
                elements.push({
                    type: txtM[1],
                    x: parseInt(txtM[3]), y: parseInt(txtM[4]),
                    w: 0, h: 0, // text autosizes
                    color: '#ffffff', // placeholder
                    // The text content is stored in Name for text elements, or we parse it
                    name: txtM[2] // content
                });
                continue;
            }

            // 7. PushImage (Assets)
            // tft.pushImage(x, y, w, h, assetName)
            const imgM = trimmed.match(/tft\.pushImage\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([a-zA-Z0-9_]+)/);
            if (imgM) {
                const assetName = imgM[5];

                // FIX: Ignore pushImage if it's the background call for this screen
                // Convention: background is named "{fnName}_bg" OR matches the screen.backgroundAsset
                const isBackground = (assetName === `${fnName}_bg`);
                if (isBackground) continue;

                elements.push({
                    type: 'rect', // represented as rect with asset
                    x: parseInt(imgM[1]), y: parseInt(imgM[2]),
                    w: parseInt(imgM[3]), h: parseInt(imgM[4]),
                    asset: assetName,
                    name: name || assetName
                });
            }
        }
        return elements;
    }

    // ─── TFT Code Parser → Live Canvas Preview ────────────────────────────────
    _rgb565ToStr(color565) {
        const r = ((color565 >> 11) & 0x1F) * 8;
        const g = ((color565 >> 5) & 0x3F) * 4;
        const b = (color565 & 0x1F) * 8;
        return `rgb(${r},${g},${b})`;
    }

    _resolveColor(tok) {
        tok = (tok || '').trim();
        if (this._tftColors[tok] !== undefined) return this._rgb565ToStr(this._tftColors[tok]);
        if (tok.startsWith('0x') || tok.startsWith('0X')) return this._rgb565ToStr(parseInt(tok, 16));
        if (!isNaN(tok)) return this._rgb565ToStr(parseInt(tok));
        return '#888';
    }

    _parseArgs(str) {
        const args = [];
        let depth = 0, cur = '', inStr = false;
        for (const ch of str) {
            if (ch === '"' || ch === "'") inStr = !inStr;
            if (!inStr && ch === '(') depth++;
            if (!inStr && ch === ')') depth--;
            if (!inStr && ch === ',' && depth === 0) { args.push(cur.trim()); cur = ''; }
            else cur += ch;
        }
        if (cur.trim()) args.push(cur.trim());
        return args;
    }

    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    parseAndRenderCode(code) {
        if (!this.dom.canvas) return;
        const ctx = this.ctx;
        const W = this.dom.canvas.width;
        const H = this.dom.canvas.height;

        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);

        let textColor = '#ffffff';
        let fontSize = 8;

        for (const line of code.split('\n')) {
            const trimmed = line.trim();
            if (trimmed.startsWith('//') || trimmed.startsWith('*')) continue;

            const match = trimmed.match(/tft\.(\w+)(?:<[^>]*>)?\s*\(([^;]*)\)/);
            if (!match) continue;

            const cmd = match[1];
            const args = this._parseArgs(match[2]);

            try {
                switch (cmd) {
                    case 'fillScreen':
                        ctx.fillStyle = this._resolveColor(args[0]);
                        ctx.fillRect(0, 0, W, H);
                        break;
                    case 'fillRect':
                        ctx.fillStyle = this._resolveColor(args[4]);
                        ctx.fillRect(+args[0], +args[1], +args[2], +args[3]);
                        break;
                    case 'drawRect':
                        ctx.strokeStyle = this._resolveColor(args[4]);
                        ctx.lineWidth = 1;
                        ctx.strokeRect(+args[0] + 0.5, +args[1] + 0.5, +args[2], +args[3]);
                        ctx.strokeRect(+args[0] + 0.5, +args[1] + 0.5, +args[2], +args[3]);
                        break;
                    case 'fillRoundRect':
                        ctx.fillStyle = this._resolveColor(args[5]);
                        this._roundRect(ctx, +args[0], +args[1], +args[2], +args[3], +args[4]);
                        ctx.fill();
                        break;
                    case 'drawRoundRect':
                        ctx.strokeStyle = this._resolveColor(args[5]);
                        ctx.lineWidth = 1;
                        this._roundRect(ctx, +args[0], +args[1], +args[2], +args[3], +args[4]);
                        ctx.stroke();
                        break;
                    case 'fillCircle':
                        ctx.fillStyle = this._resolveColor(args[3]);
                        ctx.beginPath();
                        ctx.arc(+args[0], +args[1], +args[2], 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'drawCircle':
                        ctx.strokeStyle = this._resolveColor(args[3]);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(+args[0], +args[1], +args[2], 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'fillTriangle': {
                        ctx.fillStyle = this._resolveColor(args[6]);
                        ctx.beginPath();
                        ctx.moveTo(+args[0], +args[1]);
                        ctx.lineTo(+args[2], +args[3]);
                        ctx.lineTo(+args[4], +args[5]);
                        ctx.closePath(); ctx.fill();
                        break;
                    }
                    case 'drawLine':
                        ctx.strokeStyle = this._resolveColor(args[4]);
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(+args[0], +args[1]);
                        ctx.lineTo(+args[2], +args[3]);
                        ctx.stroke();
                        break;
                    case 'drawPixel':
                        ctx.fillStyle = this._resolveColor(args[2]);
                        ctx.fillRect(+args[0], +args[1], 1, 1);
                        break;
                    case 'setTextColor':
                        textColor = this._resolveColor(args[0]);
                        break;
                    case 'setTextSize':
                        fontSize = Math.max(6, (+args[0] || 1) * 8);
                        break;
                    case 'drawString':
                    case 'drawCentreString':
                    case 'setCursor':
                        break; // handled by print/println
                    case 'print':
                    case 'println': {
                        const txt = args[0]?.replace(/^["']|["']$/g, '') || '';
                        ctx.fillStyle = textColor;
                        ctx.font = `${fontSize}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.fillText(txt, 0, fontSize);
                        break;
                    }
                    case 'pushImage': {
                        // Draw the imported design background if available
                        if (this._bgImage && this._bgImage.complete) {
                            ctx.drawImage(this._bgImage, +args[0], +args[1], +args[2] || W, +args[3] || H);
                        } else {
                            // Placeholder while image not loaded
                            ctx.strokeStyle = '#38bdf8';
                            ctx.setLineDash([4, 4]);
                            ctx.strokeRect(+args[0] + 0.5, +args[1] + 0.5, +args[2] || W, +args[3] || H);
                            ctx.setLineDash([]);
                            ctx.fillStyle = 'rgba(56,189,248,0.08)';
                            ctx.fillRect(+args[0], +args[1], +args[2] || W, +args[3] || H);
                            ctx.fillStyle = '#38bdf8';
                            ctx.font = '10px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(`[ ${args[4] || 'image'} ]`, (+args[0] + (+args[2] || W) / 2), (+args[1] + (+args[3] || H) / 2));
                            ctx.textAlign = 'left';
                        }
                        break;
                    }
                }
            } catch (err) { /* skip malformed commands */ }
        }
    }

    // ─── Inspector / Properties Panel ─────────────────────────────────────────
    renderInspector(model) {
        if (!this.dom.interactionPanel) return;

        const screen = model.activeScreen;
        const el = screen ? screen.elements.find(e => e.id === model.selectedElementId) : null;

        if (!el) {
            this.dom.interactionPanel.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;
                            color: var(--text-muted); gap: 10px; opacity: 0.5; padding: 20px;">
                    <i data-lucide="mouse-pointer-2" style="width: 32px; height: 32px;"></i>
                    <span style="font-size: 0.7rem;">Selecione um elemento</span>
                </div>
            `;
            if (window.lucide) window.lucide.createIcons();
            return;
        }

        this.dom.interactionPanel.innerHTML = `
            <div class="inspector-group">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">PROPRIEDADES</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div class="input-field compact">
                        <span>Nome</span>
                        <input type="text" data-prop="name" value="${el.name || ''}">
                    </div>
                    <div class="input-field compact">
                        <span>Cor</span>
                        <input type="color" data-prop="color" value="${el.color || '#38bdf8'}">
                    </div>
                </div>
            </div>

            <div class="inspector-group" style="margin-top:12px;">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">POSIÇÃO & TAMANHO</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div class="input-field compact"><span>X</span><input type="number" data-prop="x" value="${el.x ?? 10}"></div>
                    <div class="input-field compact"><span>Y</span><input type="number" data-prop="y" value="${el.y ?? 10}"></div>
                    <div class="input-field compact"><span>W</span><input type="number" data-prop="w" value="${el.w ?? 50}"></div>
                    <div class="input-field compact"><span>H</span><input type="number" data-prop="h" value="${el.h ?? 50}"></div>
                </div>
            </div>

            <div class="inspector-group" style="margin-top:12px;">
                <div class="inspector-label" style="font-size:0.6rem;color:var(--primary);font-weight:800;margin-bottom:10px;letter-spacing:1px;">INTERAÇÃO</div>
                <div class="input-field compact">
                    <span>Ir para Tela</span>
                    <select data-prop="targetScreenId" style="width:100%;">
                        <option value="">Nenhuma</option>
                        ${model.screens.map(s => `<option value="${s.id}" ${el.targetScreenId === s.id ? 'selected' : ''}>${s.name}</option>`).join('')}
                    </select>
                </div>
            </div>

            <button class="secondary-btn del-el-btn" style="width:100%;margin-top:12px;color:#ef4444;border-color:rgba(239,68,68,0.2);">
                <i data-lucide="trash-2" style="width:14px;"></i> Excluir
            </button>
        `;

        this.dom.interactionPanel.querySelectorAll('input, select').forEach(input => {
            const fire = (e) => {
                const prop = e.target.dataset.prop;
                let val = e.target.value;
                if (e.target.type === 'number') val = parseInt(val) || 0;
                // Optimistic: update local element + redraw immediately
                el[prop] = val;
                if (!this._codeEditedManually) this._drawToCanvas(model.activeScreen, this.dom.canvas, model.assets);
                // Persist to backend
                this.onPropertyChange?.(el.id, prop, val);
            };
            input.oninput = fire;
            if
